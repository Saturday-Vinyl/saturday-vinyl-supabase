# Saturday Firmware Manifest Schema

**Version:** 1.0.0
**Last Updated:** 2026-01-24
**Audience:** Firmware engineers, Admin App developers

---

## Overview

The Firmware Manifest is a JSON document embedded in Saturday device firmware that describes the device's capabilities, supported commands, and expected data schemas. This manifest enables the Admin App to dynamically adapt its UI and validation logic based on the connected device's capabilities.

The manifest is generated by the Admin App from capability configurations and exported as a JSON file for embedding in firmware projects.

---

## Manifest Structure

```json
{
  "manifest_version": "1.0",
  "device_type": "hub",
  "device_name": "Saturday Vinyl Hub",
  "firmware_id": "550e8400-e29b-41d4-a716-446655440000",
  "firmware_version": "1.2.0",
  "soc_types": ["esp32s3", "esp32h2"],
  "master_soc": "esp32s3",
  "capabilities": {
    "wifi": { ... },
    "thread": { ... },
    "cloud": { ... },
    "rfid": { ... }
  },
  "commands": ["factory_provision", "get_status", "run_test", "reboot", ...],
  "heartbeat_interval_ms": 30000
}
```

---

## Field Reference

### Root Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `manifest_version` | string | Yes | Schema version (currently "1.0") |
| `device_type` | string | Yes | Device type identifier (e.g., "hub", "crate") |
| `device_name` | string | Yes | Human-readable device name |
| `firmware_id` | uuid | Yes | UUID from `firmware` table |
| `firmware_version` | string | Yes | Semantic version (e.g., "1.2.0") |
| `soc_types` | string[] | Yes | SoC types on this PCB |
| `master_soc` | string | Yes | Which SoC has network connectivity |
| `capabilities` | object | Yes | Capability definitions (keyed by name) |
| `commands` | string[] | Yes | Supported command names |
| `heartbeat_interval_ms` | integer | No | Recommended heartbeat interval |

### Capability Object

Each capability in the `capabilities` object has the following structure:

```json
{
  "wifi": {
    "display_name": "Wi-Fi",
    "factory_attributes": {
      "ssid": {"type": "string", "max_length": 32},
      "password": {"type": "string", "max_length": 64}
    },
    "consumer_attributes": {
      "ssid": {"type": "string", "required": true},
      "password": {"type": "string", "required": true}
    },
    "heartbeat_attributes": {
      "connected": {"type": "boolean"},
      "rssi": {"type": "integer"}
    },
    "tests": [
      {
        "name": "connect",
        "display_name": "Connect to Wi-Fi",
        "parameters": {
          "ssid": {"type": "string"},
          "password": {"type": "string"},
          "timeout_ms": {"type": "integer", "default": 30000}
        }
      }
    ]
  }
}
```

---

## Simplified Attribute Schema

For firmware embedding, attribute schemas use a simplified format (not full JSON Schema):

### Type Definitions

| Type | Description | Example |
|------|-------------|---------|
| `string` | UTF-8 string | `"value"` |
| `integer` | 32-bit signed integer | `42` |
| `number` | IEEE 754 double | `3.14` |
| `boolean` | true/false | `true` |
| `object` | Nested object | `{"key": "value"}` |
| `array` | Array of items | `[1, 2, 3]` |

### Attribute Field Properties

| Property | Type | Description |
|----------|------|-------------|
| `type` | string | Data type |
| `required` | boolean | Whether field is required |
| `default` | any | Default value |
| `min` | number | Minimum value (for numbers) |
| `max` | number | Maximum value (for numbers) |
| `min_length` | integer | Minimum string length |
| `max_length` | integer | Maximum string length |
| `pattern` | string | Regex pattern for validation |
| `enum` | array | Allowed values |

---

## Example Manifests

### Saturday Hub (ESP32-S3 + ESP32-H2)

```json
{
  "manifest_version": "1.0",
  "device_type": "hub",
  "device_name": "Saturday Vinyl Hub",
  "firmware_id": "550e8400-e29b-41d4-a716-446655440000",
  "firmware_version": "1.2.0",
  "soc_types": ["esp32s3", "esp32h2"],
  "master_soc": "esp32s3",
  "capabilities": {
    "wifi": {
      "display_name": "Wi-Fi",
      "factory_attributes": {
        "ssid": {"type": "string", "max_length": 32},
        "password": {"type": "string", "max_length": 64}
      },
      "consumer_attributes": {
        "ssid": {"type": "string", "required": true, "max_length": 32},
        "password": {"type": "string", "required": true, "max_length": 64}
      },
      "heartbeat_attributes": {
        "connected": {"type": "boolean"},
        "ssid": {"type": "string"},
        "rssi": {"type": "integer"}
      },
      "tests": [
        {
          "name": "connect",
          "display_name": "Connect to Wi-Fi",
          "parameters": {
            "ssid": {"type": "string"},
            "password": {"type": "string"},
            "timeout_ms": {"type": "integer", "default": 30000}
          }
        },
        {
          "name": "scan",
          "display_name": "Scan Networks",
          "parameters": {
            "timeout_ms": {"type": "integer", "default": 10000}
          }
        }
      ]
    },
    "thread": {
      "display_name": "Thread (Border Router)",
      "factory_attributes": {},
      "factory_provision_attributes": {
        "network_name": {"type": "string"},
        "pan_id": {"type": "integer"},
        "channel": {"type": "integer"},
        "network_key": {"type": "string"},
        "extended_pan_id": {"type": "string"},
        "mesh_local_prefix": {"type": "string"},
        "pskc": {"type": "string"}
      },
      "heartbeat_attributes": {
        "connected": {"type": "boolean"},
        "role": {"type": "string", "enum": ["disabled", "detached", "child", "router", "leader"]}
      },
      "tests": [
        {
          "name": "form",
          "display_name": "Form Thread Network",
          "parameters": {
            "timeout_ms": {"type": "integer", "default": 30000}
          }
        }
      ]
    },
    "cloud": {
      "display_name": "Cloud",
      "factory_attributes": {
        "cloud_url": {"type": "string", "required": true},
        "cloud_anon_key": {"type": "string", "required": true}
      },
      "heartbeat_attributes": {
        "connected": {"type": "boolean"},
        "latency_ms": {"type": "integer"}
      },
      "tests": [
        {
          "name": "ping",
          "display_name": "Test Cloud Connection",
          "parameters": {
            "timeout_ms": {"type": "integer", "default": 15000}
          }
        }
      ]
    },
    "rfid": {
      "display_name": "RFID",
      "factory_attributes": {
        "power_dbm": {"type": "integer", "default": 20, "min": 0, "max": 30}
      },
      "heartbeat_attributes": {
        "module_firmware": {"type": "string"},
        "last_scan_count": {"type": "integer"}
      },
      "tests": [
        {
          "name": "scan",
          "display_name": "Scan for Tags",
          "parameters": {
            "duration_ms": {"type": "integer", "default": 5000}
          }
        }
      ]
    }
  },
  "commands": [
    "factory_provision",
    "get_status",
    "get_capabilities",
    "set_factory_attributes",
    "get_factory_attributes",
    "set_consumer_attributes",
    "get_consumer_attributes",
    "run_test",
    "reboot",
    "consumer_reset",
    "factory_reset",
    "ota_update"
  ],
  "heartbeat_interval_ms": 30000
}
```

### Saturday Crate (ESP32-S3 + ESP32-H2)

```json
{
  "manifest_version": "1.0",
  "device_type": "crate",
  "device_name": "Saturday Vinyl Crate",
  "firmware_id": "660e8400-e29b-41d4-a716-446655440001",
  "firmware_version": "1.0.0",
  "soc_types": ["esp32s3", "esp32h2"],
  "master_soc": "esp32s3",
  "capabilities": {
    "thread": {
      "display_name": "Thread",
      "factory_attributes": {
        "network_name": {"type": "string", "max_length": 16},
        "network_key": {"type": "string", "pattern": "^[0-9a-fA-F]{32}$"}
      },
      "consumer_attributes": {
        "network_name": {"type": "string"},
        "network_key": {"type": "string"}
      },
      "heartbeat_attributes": {
        "connected": {"type": "boolean"},
        "role": {"type": "string"}
      },
      "tests": [
        {
          "name": "join",
          "display_name": "Join Thread Network",
          "parameters": {
            "timeout_ms": {"type": "integer", "default": 60000}
          }
        }
      ]
    },
    "rfid": {
      "display_name": "RFID",
      "factory_attributes": {
        "power_dbm": {"type": "integer", "default": 15}
      },
      "heartbeat_attributes": {
        "module_firmware": {"type": "string"},
        "last_scan_count": {"type": "integer"}
      },
      "tests": [
        {
          "name": "scan",
          "display_name": "Scan for Tags",
          "parameters": {
            "duration_ms": {"type": "integer", "default": 5000}
          }
        }
      ]
    },
    "led": {
      "display_name": "LED Strip",
      "factory_attributes": {
        "led_count": {"type": "integer", "default": 8},
        "led_type": {"type": "string", "default": "SK6812"}
      },
      "tests": [
        {
          "name": "pattern",
          "display_name": "Test LED Pattern",
          "parameters": {
            "pattern": {"type": "string", "enum": ["rainbow", "solid", "chase"], "default": "rainbow"}
          }
        }
      ]
    },
    "environment": {
      "display_name": "Environment Sensor",
      "heartbeat_attributes": {
        "temperature_c": {"type": "number"},
        "humidity_pct": {"type": "number"},
        "in_safe_range": {"type": "boolean"}
      },
      "tests": [
        {
          "name": "read",
          "display_name": "Read Environment",
          "parameters": {}
        }
      ]
    },
    "motion": {
      "display_name": "Motion Sensor",
      "tests": [
        {
          "name": "detect",
          "display_name": "Detect Motion",
          "parameters": {
            "timeout_ms": {"type": "integer", "default": 30000}
          }
        }
      ]
    }
  },
  "commands": [
    "factory_provision",
    "get_status",
    "get_capabilities",
    "set_factory_attributes",
    "set_consumer_attributes",
    "run_test",
    "reboot",
    "consumer_reset",
    "factory_reset",
    "ota_update"
  ],
  "heartbeat_interval_ms": 30000
}
```

---

## Firmware Embedding

### ESP-IDF Integration

Use `EMBED_TXTFILES` in CMakeLists.txt:

```cmake
idf_component_register(
    SRCS "main.c"
    INCLUDE_DIRS "include"
    EMBED_TXTFILES "firmware_manifest.json"
    REQUIRES nvs_flash cJSON
)
```

Access in code:

```c
extern const char firmware_manifest_start[] asm("_binary_firmware_manifest_json_start");
extern const char firmware_manifest_end[] asm("_binary_firmware_manifest_json_end");

const char* get_manifest(void) {
    return firmware_manifest_start;
}

size_t get_manifest_length(void) {
    return firmware_manifest_end - firmware_manifest_start;
}
```

### Responding to get_capabilities

```c
void handle_get_capabilities(const char* cmd_id) {
    cJSON *response = cJSON_CreateObject();
    cJSON_AddStringToObject(response, "id", cmd_id);
    cJSON_AddStringToObject(response, "status", "ok");

    size_t len = get_manifest_length();
    cJSON *manifest = cJSON_ParseWithLength(firmware_manifest_start, len);
    cJSON_AddItemToObject(response, "data", manifest);

    char *json = cJSON_PrintUnformatted(response);
    send_response(json);

    cJSON_free(json);
    cJSON_Delete(response);
}
```

---

## Admin App Export

The Admin App generates firmware manifests from capability configurations:

1. Select device type in Admin App
2. Navigate to "Firmware" section
3. Click "Export Manifest"
4. Select target firmware version
5. Save JSON file to firmware project

The export process:

1. Loads device type with linked capabilities
2. Filters to active capabilities
3. Simplifies JSON Schema to embedded format
4. Includes firmware metadata from selected version
5. Generates JSON file

---

## Validation

### Admin App Validation

The Admin App validates incoming data against manifest schemas:

```dart
bool validateFactoryAttributes(
  Map<String, dynamic> manifest,
  Map<String, dynamic> attributes,
) {
  final capabilities = manifest['capabilities'] as Map<String, dynamic>;

  for (final entry in capabilities.entries) {
    final capName = entry.key;
    final capDef = entry.value as Map<String, dynamic>;
    final factoryAttrs = capDef['factory_attributes'] as Map<String, dynamic>?;

    if (factoryAttrs != null && attributes.containsKey(capName)) {
      final capData = attributes[capName] as Map<String, dynamic>;
      if (!_validateObject(factoryAttrs, capData)) {
        return false;
      }
    }
  }

  return true;
}
```

### Firmware Validation

Firmware validates provisioning data against embedded schema:

```c
bool validate_factory_attributes(cJSON *attributes) {
    cJSON *manifest = cJSON_ParseWithLength(firmware_manifest_start,
                                            get_manifest_length());
    cJSON *capabilities = cJSON_GetObjectItem(manifest, "capabilities");

    // Iterate capabilities and validate matching attributes
    cJSON *cap;
    cJSON_ArrayForEach(cap, capabilities) {
        const char *cap_name = cap->string;
        cJSON *cap_data = cJSON_GetObjectItem(attributes, cap_name);

        if (cap_data) {
            cJSON *factory_attrs = cJSON_GetObjectItem(cap, "factory_attributes");
            if (!validate_object(factory_attrs, cap_data)) {
                cJSON_Delete(manifest);
                return false;
            }
        }
    }

    cJSON_Delete(manifest);
    return true;
}
```

---

## Migration from Service Mode Manifest

### Key Changes

| Service Mode Manifest | Firmware Manifest |
|----------------------|-------------------|
| `capabilities` as boolean flags | `capabilities` as full objects with schemas |
| `provisioning_fields` object | Derived from `factory_attributes` |
| `supported_tests` array | Derived from capability `tests` |
| `status_fields` array | Derived from `heartbeat_attributes` |
| `custom_commands` array | `commands` array |
| `led_patterns` object | Moved to LED capability config |

### Migration Steps

1. Replace boolean `capabilities` with full capability objects
2. Move provisioning field definitions into capability `factory_attributes`
3. Define tests within each capability's `tests` array
4. Add `soc_types` and `master_soc` for multi-SoC devices
5. Export new manifest from Admin App after capability configuration

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| 1.0.0 | 2026-01-24 | Initial firmware manifest schema specification |

---

*This document is proprietary to Saturday Vinyl. Do not distribute externally.*
