import 'package:saturday_app/models/gcode_file.dart';
import 'package:saturday_app/repositories/gcode_file_repository.dart';
import 'package:saturday_app/services/github_service.dart';
import 'package:saturday_app/utils/app_logger.dart';

/// Result of a sync operation
class SyncResult {
  final int filesAdded;
  final int filesUpdated;
  final int filesDeleted;
  final int errors;
  final List<String> errorMessages;

  SyncResult({
    required this.filesAdded,
    required this.filesUpdated,
    required this.filesDeleted,
    required this.errors,
    required this.errorMessages,
  });

  int get totalChanges => filesAdded + filesUpdated + filesDeleted;
  bool get hasChanges => totalChanges > 0;
  bool get hasErrors => errors > 0;

  @override
  String toString() {
    return 'SyncResult(added: $filesAdded, updated: $filesUpdated, deleted: $filesDeleted, errors: $errors)';
  }
}

/// Service for syncing gCode files from GitHub repository to local database
class GCodeSyncService {
  final GitHubService _githubService;
  final GCodeFileRepository _repository;

  GCodeSyncService({
    GitHubService? githubService,
    GCodeFileRepository? repository,
  })  : _githubService = githubService ?? GitHubService(),
        _repository = repository ?? GCodeFileRepository();

  /// Sync gCode files from GitHub repository to database
  ///
  /// Scans the repository for .gcode files, reads READMEs for descriptions,
  /// and updates the database accordingly.
  Future<SyncResult> syncRepository() async {
    int added = 0;
    int updated = 0;
    int deleted = 0;
    final errors = <String>[];

    try {
      AppLogger.info('Starting gCode repository sync');

      // Get all gCode files from GitHub
      final githubFiles = await _githubService.getAllGCodeFiles();
      AppLogger.info('Found ${githubFiles.length} gCode files in GitHub');

      // Get all existing files from database
      final existingFiles = await _repository.getAllGCodeFiles();
      final existingPaths = existingFiles.map((f) => f.githubPath).toSet();

      // Track processed paths to identify deletions
      final processedPaths = <String>{};

      // Process each GitHub file
      for (final githubFile in githubFiles) {
        try {
          processedPaths.add(githubFile.path);

          // Determine machine type from path
          final machineType = _getMachineType(githubFile.path);
          if (machineType == null) {
            errors.add('Unknown machine type for file: ${githubFile.path}');
            continue;
          }

          // Get directory containing the file
          final dirPath = _getDirectoryPath(githubFile.path);

          // Try to read README for description
          String? description;
          if (dirPath.isNotEmpty) {
            final readme = await _githubService.getReadme(dirPath);
            if (readme != null) {
              description = _extractH1FromMarkdown(readme);
            }
          }

          // Create gCode file model
          final gcodeFile = GCodeFile(
            id: '', // Will be generated by database
            githubPath: githubFile.path,
            fileName: githubFile.name,
            description: description,
            machineType: machineType,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          );

          // Upsert the file
          await _repository.upsertGCodeFile(gcodeFile);

          if (existingPaths.contains(githubFile.path)) {
            updated++;
          } else {
            added++;
          }
        } catch (error) {
          final errorMsg = 'Error processing ${githubFile.path}: $error';
          AppLogger.warning(errorMsg);
          errors.add(errorMsg);
        }
      }

      // Identify and delete files that no longer exist in GitHub
      for (final existingFile in existingFiles) {
        if (!processedPaths.contains(existingFile.githubPath)) {
          try {
            await _repository.deleteGCodeFile(existingFile.id);
            deleted++;
            AppLogger.info('Deleted file no longer in GitHub: ${existingFile.githubPath}');
          } catch (error) {
            final errorMsg = 'Error deleting ${existingFile.githubPath}: $error';
            AppLogger.warning(errorMsg);
            errors.add(errorMsg);
          }
        }
      }

      final result = SyncResult(
        filesAdded: added,
        filesUpdated: updated,
        filesDeleted: deleted,
        errors: errors.length,
        errorMessages: errors,
      );

      AppLogger.info('Sync completed: $result');
      return result;
    } catch (error, stackTrace) {
      AppLogger.error('Fatal error during sync', error, stackTrace);
      return SyncResult(
        filesAdded: added,
        filesUpdated: updated,
        filesDeleted: deleted,
        errors: errors.length + 1,
        errorMessages: [...errors, 'Fatal error: $error'],
      );
    }
  }

  /// Determine machine type from file path
  ///
  /// Expects paths like: cnc/file.gcode, laser/file.gcode, or folder-name/file.gcode
  /// Looks for 'cnc', 'laser', or 'probe' keywords in the path
  String? _getMachineType(String path) {
    final parts = path.split('/');
    final lowerPath = path.toLowerCase();

    // Look for 'cnc' in the path segments
    if (parts.contains('cnc') ||
        lowerPath.contains('/cnc/') ||
        lowerPath.startsWith('cnc/')) {
      return 'cnc';
    }

    // Look for 'laser' in the path segments
    if (parts.contains('laser') ||
        lowerPath.contains('/laser/') ||
        lowerPath.startsWith('laser/')) {
      return 'laser';
    }

    // Look for 'probe' in the path - these are CNC calibration files
    if (lowerPath.contains('probe') ||
        lowerPath.contains('calibration') ||
        lowerPath.contains('macro')) {
      AppLogger.info('Detected CNC probe/calibration file: $path');
      return 'cnc';
    }

    // Default to CNC if no specific type is found
    // This ensures files don't get skipped
    AppLogger.warning('Unable to determine specific machine type for $path, defaulting to CNC');
    return 'cnc';
  }

  /// Get directory path from file path
  String _getDirectoryPath(String filePath) {
    final lastSlash = filePath.lastIndexOf('/');
    if (lastSlash == -1) return '';
    return filePath.substring(0, lastSlash);
  }

  /// Extract H1 heading from markdown content
  ///
  /// Looks for the first line starting with '# ' and returns the text after it
  String? _extractH1FromMarkdown(String markdown) {
    final lines = markdown.split('\n');

    for (final line in lines) {
      final trimmed = line.trim();
      if (trimmed.startsWith('# ') && trimmed.length > 2) {
        return trimmed.substring(2).trim();
      }
    }

    return null;
  }

  /// Validate GitHub connection and credentials
  Future<bool> validateConnection() async {
    try {
      AppLogger.info('Validating GitHub connection');
      return await _githubService.validateToken();
    } catch (error, stackTrace) {
      AppLogger.error('Error validating GitHub connection', error, stackTrace);
      return false;
    }
  }

  /// Get repository information
  Future<Map<String, dynamic>?> getRepositoryInfo() async {
    try {
      return await _githubService.getRepositoryInfo();
    } catch (error, stackTrace) {
      AppLogger.error('Error getting repository info', error, stackTrace);
      return null;
    }
  }

  /// Fetch gCode file content from GitHub
  ///
  /// [file] - GCodeFile object containing githubPath
  /// Returns the gCode content as a string
  Future<String> fetchGCodeContent(GCodeFile file) async {
    try {
      AppLogger.info('Fetching gCode content for: ${file.fileName}');
      final content = await _githubService.getFileContents(file.githubPath);
      AppLogger.info('Successfully fetched gCode content: ${content.length} bytes');
      return content;
    } catch (error, stackTrace) {
      AppLogger.error('Error fetching gCode content for ${file.fileName}', error, stackTrace);
      rethrow;
    }
  }
}
