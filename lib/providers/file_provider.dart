import 'dart:typed_data';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:saturday_app/models/app_file.dart';
import 'package:saturday_app/models/step_file.dart';
import 'package:saturday_app/repositories/file_repository.dart';
import 'package:saturday_app/repositories/step_file_repository.dart';
import 'package:saturday_app/services/auth_service.dart';
import 'package:saturday_app/services/file_storage_service.dart';
import 'package:saturday_app/utils/app_logger.dart';

/// Provider for FileRepository
final fileRepositoryProvider = Provider<FileRepository>((ref) {
  return FileRepository();
});

/// Provider for FileStorageService
final fileStorageServiceProvider = Provider<FileStorageService>((ref) {
  return FileStorageService();
});

/// Provider for StepFileRepository
final stepFileRepositoryProvider = Provider<StepFileRepository>((ref) {
  return StepFileRepository();
});

/// Provider for all files in the library
final allFilesProvider = FutureProvider<List<AppFile>>((ref) async {
  final repository = ref.watch(fileRepositoryProvider);
  return await repository.getAllFiles();
});

/// Provider for a single file by ID (family provider)
final fileByIdProvider = FutureProvider.family<AppFile?, String>((ref, fileId) async {
  final repository = ref.watch(fileRepositoryProvider);
  return await repository.getFileById(fileId);
});

/// Provider for searching files
final fileSearchProvider = FutureProvider.family<List<AppFile>, String>((ref, query) async {
  if (query.isEmpty) {
    return await ref.watch(fileRepositoryProvider).getAllFiles();
  }
  return await ref.watch(fileRepositoryProvider).searchFiles(query);
});

/// Provider for step files (files attached to a production step)
final stepFilesProvider = FutureProvider.family<List<StepFile>, String>((ref, stepId) async {
  final repository = ref.watch(stepFileRepositoryProvider);
  return await repository.getFilesForStep(stepId);
});

/// Provider for file management actions
final fileManagementProvider = Provider((ref) => FileManagement(ref));

/// File management actions
class FileManagement {
  final Ref ref;

  FileManagement(this.ref);

  /// Upload a new file to the library
  Future<AppFile> uploadFile({
    required Uint8List fileBytes,
    required String fileName,
    required String description,
    required String mimeType,
  }) async {
    try {
      AppLogger.info('Uploading file: $fileName');

      // Get current user name
      final currentUser = AuthService.instance.getCurrentUser();
      final uploaderName = currentUser?.userMetadata?['full_name'] as String? ??
                          currentUser?.email ??
                          'Unknown';

      // Upload file to storage
      final storageService = ref.read(fileStorageServiceProvider);
      final storagePath = await storageService.uploadFile(
        fileBytes,
        fileName,
        mimeType,
      );

      // Create database record
      final file = AppFile(
        id: '', // Will be generated by database
        storagePath: storagePath,
        fileName: fileName,
        description: description.isEmpty ? null : description,
        mimeType: mimeType,
        fileSizeBytes: fileBytes.length,
        uploadedByName: uploaderName,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      final repository = ref.read(fileRepositoryProvider);
      final createdFile = await repository.createFile(file);

      // Invalidate files list to refresh
      ref.invalidate(allFilesProvider);

      AppLogger.info('File uploaded successfully: ${createdFile.id}');
      return createdFile;
    } catch (error, stackTrace) {
      AppLogger.error('Failed to upload file', error, stackTrace);
      rethrow;
    }
  }

  /// Update file metadata (name, description)
  Future<AppFile> updateFile(AppFile file) async {
    try {
      AppLogger.info('Updating file: ${file.id}');

      final repository = ref.read(fileRepositoryProvider);
      final updatedFile = await repository.updateFile(file);

      // Invalidate providers to refresh
      ref.invalidate(allFilesProvider);
      ref.invalidate(fileByIdProvider(file.id));

      AppLogger.info('File updated successfully');
      return updatedFile;
    } catch (error, stackTrace) {
      AppLogger.error('Failed to update file', error, stackTrace);
      rethrow;
    }
  }

  /// Delete a file from the library
  /// This will also delete the file from storage
  Future<void> deleteFile(AppFile file) async {
    try {
      AppLogger.info('Deleting file: ${file.id}');

      // Delete from storage first
      final storageService = ref.read(fileStorageServiceProvider);
      await storageService.deleteFile(file.storagePath);

      // Delete from database
      final repository = ref.read(fileRepositoryProvider);
      await repository.deleteFile(file.id);

      // Invalidate providers to refresh
      ref.invalidate(allFilesProvider);

      AppLogger.info('File deleted successfully');
    } catch (error, stackTrace) {
      AppLogger.error('Failed to delete file', error, stackTrace);
      rethrow;
    }
  }

  /// Download file content
  Future<Uint8List> downloadFile(AppFile file) async {
    try {
      AppLogger.info('Downloading file: ${file.fileName}');

      final storageService = ref.read(fileStorageServiceProvider);
      final bytes = await storageService.downloadFile(file.storagePath);

      AppLogger.info('File downloaded successfully');
      return bytes;
    } catch (error, stackTrace) {
      AppLogger.error('Failed to download file', error, stackTrace);
      rethrow;
    }
  }

  /// Check if a file name is available
  Future<bool> isFileNameAvailable(String fileName, {String? excludeFileId}) async {
    try {
      final repository = ref.read(fileRepositoryProvider);
      return await repository.isFileNameAvailable(fileName, excludeFileId: excludeFileId);
    } catch (error, stackTrace) {
      AppLogger.error('Failed to check file name availability', error, stackTrace);
      rethrow;
    }
  }

  /// Attach files to a production step
  Future<void> attachFilesToStep({
    required String stepId,
    required List<String> fileIds,
  }) async {
    try {
      AppLogger.info('Attaching ${fileIds.length} files to step: $stepId');

      final repository = ref.read(stepFileRepositoryProvider);
      await repository.updateFilesForStep(
        stepId: stepId,
        fileIds: fileIds,
      );

      // Invalidate step files provider to refresh
      ref.invalidate(stepFilesProvider(stepId));

      AppLogger.info('Files attached to step successfully');
    } catch (error, stackTrace) {
      AppLogger.error('Failed to attach files to step', error, stackTrace);
      rethrow;
    }
  }

  /// Get steps using a specific file
  Future<List<StepFile>> getStepsUsingFile(String fileId) async {
    try {
      final repository = ref.read(stepFileRepositoryProvider);
      return await repository.getStepsUsingFile(fileId);
    } catch (error, stackTrace) {
      AppLogger.error('Failed to get steps using file', error, stackTrace);
      rethrow;
    }
  }
}
