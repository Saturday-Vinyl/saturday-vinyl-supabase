-- WARNING: This schema is for context only and is not meant to be run.
-- Table order and constraints may not be valid for execution.
-- Auto-generated by scripts/generate-schema-docs.sh
CREATE TYPE public.consumer_device_status AS ENUM ('online', 'offline', 'setup_required');
CREATE TYPE public.consumer_device_type AS ENUM ('hub', 'crate');
CREATE TYPE public.invitation_status AS ENUM ('pending', 'accepted', 'rejected', 'expired', 'revoked');
CREATE TYPE public.library_role AS ENUM ('owner', 'editor', 'viewer');
CREATE TYPE public.record_side AS ENUM ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H');
CREATE TYPE public.step_type AS ENUM ('general', 'cnc_milling', 'laser_cutting', 'firmware_provisioning');
CREATE TYPE public.unit_status AS ENUM ('in_production', 'inventory', 'assigned', 'claimed');
CREATE TABLE public.album_locations (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  library_album_id uuid NOT NULL,
  device_id uuid NOT NULL,
  detected_at timestamp with time zone NOT NULL DEFAULT now(),
  removed_at timestamp with time zone,
  CONSTRAINT album_locations_pkey PRIMARY KEY (id),
  CONSTRAINT album_locations_device_id_fkey FOREIGN KEY (device_id) REFERENCES consumer_devices(id) ON DELETE CASCADE,
  CONSTRAINT album_locations_library_album_id_fkey FOREIGN KEY (library_album_id) REFERENCES library_albums(id) ON DELETE CASCADE
);
CREATE TABLE public.albums (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  discogs_id integer,
  title text NOT NULL,
  artist text NOT NULL,
  year integer,
  genres text[] DEFAULT '{}'::text[],
  styles text[] DEFAULT '{}'::text[],
  label text,
  cover_image_url text,
  tracks jsonb DEFAULT '[]'::jsonb,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT albums_pkey PRIMARY KEY (id),
  CONSTRAINT albums_discogs_id_key UNIQUE (discogs_id)
);
CREATE TABLE public.capabilities (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  name character varying(100) NOT NULL,
  display_name character varying(100) NOT NULL,
  description text,
  factory_input_schema jsonb DEFAULT '{}'::jsonb,
  factory_output_schema jsonb DEFAULT '{}'::jsonb,
  consumer_input_schema jsonb DEFAULT '{}'::jsonb,
  consumer_output_schema jsonb DEFAULT '{}'::jsonb,
  heartbeat_schema jsonb DEFAULT '{}'::jsonb,
  tests jsonb DEFAULT '[]'::jsonb,
  is_active boolean DEFAULT true,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now(),
  CONSTRAINT capabilities_pkey PRIMARY KEY (id),
  CONSTRAINT capabilities_name_key UNIQUE (name)
);
CREATE TABLE public.consumer_devices (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  device_type consumer_device_type NOT NULL,
  name text NOT NULL,
  serial_number text NOT NULL,
  production_unit_id uuid,
  firmware_version text,
  status consumer_device_status NOT NULL DEFAULT 'offline'::consumer_device_status,
  battery_level integer,
  last_seen_at timestamp with time zone,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  settings jsonb DEFAULT '{}'::jsonb,
  CONSTRAINT consumer_devices_pkey PRIMARY KEY (id),
  CONSTRAINT consumer_devices_serial_number_key UNIQUE (serial_number),
  CONSTRAINT consumer_devices_production_unit_id_fkey FOREIGN KEY (production_unit_id) REFERENCES production_units(id) ON DELETE SET NULL,
  CONSTRAINT consumer_devices_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  CONSTRAINT consumer_devices_battery_level_check CHECK (battery_level >= 0 AND battery_level <= 100)
);
CREATE TABLE public.customers (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  shopify_customer_id character varying(255) NOT NULL,
  email character varying(255) NOT NULL,
  first_name character varying(100),
  last_name character varying(100),
  phone character varying(50),
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT customers_pkey PRIMARY KEY (id),
  CONSTRAINT customers_shopify_customer_id_key UNIQUE (shopify_customer_id)
);
CREATE TABLE public.device_commands (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  mac_address character varying(17) NOT NULL,
  command text NOT NULL,
  capability text,
  test_name text,
  parameters jsonb DEFAULT '{}'::jsonb,
  priority integer DEFAULT 0,
  status text DEFAULT 'pending'::text,
  expires_at timestamp with time zone,
  result jsonb,
  error_message text,
  retry_count integer DEFAULT 0,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now(),
  created_by uuid,
  CONSTRAINT device_commands_pkey PRIMARY KEY (id),
  CONSTRAINT device_commands_created_by_fkey FOREIGN KEY (created_by) REFERENCES users(id)
);
CREATE TABLE public.device_heartbeats (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  device_type text NOT NULL,
  relay_device_type text,
  relay_instance_id text,
  firmware_version text,
  battery_level integer,
  battery_charging boolean,
  wifi_rssi integer,
  thread_rssi integer,
  uptime_sec integer,
  free_heap integer,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  mac_address character varying(17),
  min_free_heap integer,
  largest_free_block integer,
  unit_id text,
  type text DEFAULT 'status'::text,
  command_id uuid,
  telemetry jsonb,
  CONSTRAINT device_heartbeats_pkey PRIMARY KEY (id),
  CONSTRAINT device_heartbeats_command_id_fkey FOREIGN KEY (command_id) REFERENCES device_commands(id),
  CONSTRAINT device_heartbeats_battery_level_check CHECK (battery_level IS NULL OR battery_level >= 0 AND battery_level <= 100)
);
CREATE TABLE public.device_status_notifications (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  unit_id uuid NOT NULL,
  user_id uuid NOT NULL,
  notification_type text NOT NULL,
  last_sent_at timestamp with time zone NOT NULL DEFAULT now(),
  context_data jsonb,
  CONSTRAINT device_status_notifications_pkey PRIMARY KEY (id),
  CONSTRAINT device_status_notifications_unit_type_unique UNIQUE (unit_id, notification_type),
  CONSTRAINT device_status_notifications_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES units(id) ON DELETE CASCADE,
  CONSTRAINT device_status_notifications_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
CREATE TABLE public.device_type_capabilities (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  device_type_id uuid NOT NULL,
  capability_id uuid NOT NULL,
  configuration jsonb DEFAULT '{}'::jsonb,
  display_order integer DEFAULT 0,
  created_at timestamp with time zone DEFAULT now(),
  CONSTRAINT device_type_capabilities_pkey PRIMARY KEY (id),
  CONSTRAINT device_type_capabilities_device_type_id_capability_id_key UNIQUE (device_type_id, capability_id),
  CONSTRAINT device_type_capabilities_capability_id_fkey FOREIGN KEY (capability_id) REFERENCES capabilities(id) ON DELETE CASCADE,
  CONSTRAINT device_type_capabilities_device_type_id_fkey FOREIGN KEY (device_type_id) REFERENCES device_types(id) ON DELETE CASCADE
);
CREATE TABLE public.device_types (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  name text NOT NULL,
  description text,
  capabilities text[] NOT NULL DEFAULT '{}'::text[],
  spec_url text,
  is_active boolean NOT NULL DEFAULT true,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  current_firmware_version character varying(50),
  chip_type character varying(20),
  soc_types text[] DEFAULT '{}'::text[],
  master_soc character varying(50),
  production_firmware_id uuid,
  dev_firmware_id uuid,
  slug character varying(100) NOT NULL,
  CONSTRAINT device_types_pkey PRIMARY KEY (id),
  CONSTRAINT device_types_dev_firmware_id_fkey FOREIGN KEY (dev_firmware_id) REFERENCES firmware(id),
  CONSTRAINT device_types_production_firmware_id_fkey FOREIGN KEY (production_firmware_id) REFERENCES firmware(id),
  CONSTRAINT device_types_slug_format CHECK (slug::text ~ '^[a-z0-9]+(-[a-z0-9]+)*$'::text),
  CONSTRAINT valid_chip_type CHECK (chip_type IS NULL OR (chip_type::text = ANY (ARRAY['esp32'::character varying, 'esp32s2'::character varying, 'esp32s3'::character varying, 'esp32c3'::character varying, 'esp32c6'::character varying, 'esp32h2'::character varying]::text[])))
);
CREATE TABLE public.devices (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  mac_address character varying(17) NOT NULL,
  unit_id uuid,
  firmware_version character varying(50),
  firmware_id uuid,
  factory_provisioned_at timestamp with time zone,
  factory_provisioned_by uuid,
  status character varying(50) DEFAULT 'unprovisioned'::character varying,
  last_seen_at timestamp with time zone,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now(),
  provision_data jsonb DEFAULT '{}'::jsonb,
  latest_telemetry jsonb DEFAULT '{}'::jsonb,
  device_type_slug character varying(100),
  consumer_provisioned_at timestamp with time zone,
  consumer_provisioned_by uuid,
  CONSTRAINT devices_pkey PRIMARY KEY (id),
  CONSTRAINT devices_mac_address_key UNIQUE (mac_address),
  CONSTRAINT devices_consumer_provisioned_by_fkey FOREIGN KEY (consumer_provisioned_by) REFERENCES users(id),
  CONSTRAINT devices_factory_provisioned_by_fkey FOREIGN KEY (factory_provisioned_by) REFERENCES users(id),
  CONSTRAINT devices_firmware_id_fkey FOREIGN KEY (firmware_id) REFERENCES firmware(id),
  CONSTRAINT devices_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES units(id),
  CONSTRAINT fk_devices_device_type_slug FOREIGN KEY (device_type_slug) REFERENCES device_types(slug)
);
CREATE TABLE public.files (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  storage_path text NOT NULL,
  file_name text NOT NULL,
  description text,
  mime_type text NOT NULL,
  file_size_bytes integer NOT NULL,
  uploaded_by_name text NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT files_pkey PRIMARY KEY (id),
  CONSTRAINT files_file_name_key UNIQUE (file_name),
  CONSTRAINT files_storage_path_key UNIQUE (storage_path),
  CONSTRAINT file_size_limit CHECK (file_size_bytes > 0 AND file_size_bytes <= 52428800)
);
CREATE TABLE public.firmware (
  id uuid NOT NULL DEFAULT extensions.uuid_generate_v4(),
  device_type_id uuid NOT NULL,
  version character varying(50) NOT NULL,
  release_notes text,
  binary_url text,
  binary_filename character varying(255),
  binary_size bigint,
  is_production_ready boolean DEFAULT false,
  created_at timestamp with time zone DEFAULT now(),
  created_by uuid,
  provisioning_manifest jsonb,
  is_critical boolean DEFAULT false,
  released_at timestamp with time zone,
  CONSTRAINT firmware_versions_pkey PRIMARY KEY (id),
  CONSTRAINT firmware_versions_device_type_id_version_key UNIQUE (device_type_id, version),
  CONSTRAINT firmware_versions_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id),
  CONSTRAINT firmware_versions_device_type_id_fkey FOREIGN KEY (device_type_id) REFERENCES device_types(id) ON DELETE CASCADE
);
CREATE TABLE public.firmware_files (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  firmware_id uuid NOT NULL,
  soc_type character varying(50) NOT NULL,
  is_master boolean DEFAULT false,
  file_url text NOT NULL,
  file_sha256 text,
  file_size integer,
  created_at timestamp with time zone DEFAULT now(),
  CONSTRAINT firmware_files_pkey PRIMARY KEY (id),
  CONSTRAINT firmware_files_firmware_id_soc_type_key UNIQUE (firmware_id, soc_type),
  CONSTRAINT firmware_files_firmware_id_fkey FOREIGN KEY (firmware_id) REFERENCES firmware(id) ON DELETE CASCADE
);
CREATE TABLE public.gcode_files (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  github_path text NOT NULL,
  file_name text NOT NULL,
  description text,
  machine_type text NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT gcode_files_pkey PRIMARY KEY (id),
  CONSTRAINT gcode_files_github_path_key UNIQUE (github_path)
);
CREATE TABLE public.legacy_qr_code_lookup (
  old_uuid uuid NOT NULL,
  unit_id uuid NOT NULL,
  notes text,
  created_at timestamp with time zone DEFAULT now(),
  CONSTRAINT legacy_qr_code_lookup_pkey PRIMARY KEY (old_uuid),
  CONSTRAINT legacy_qr_code_lookup_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES units(id) ON DELETE CASCADE
);
CREATE TABLE public.libraries (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  name text NOT NULL,
  description text,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  created_by uuid NOT NULL,
  CONSTRAINT libraries_pkey PRIMARY KEY (id),
  CONSTRAINT libraries_created_by_fkey FOREIGN KEY (created_by) REFERENCES users(id) ON DELETE CASCADE
);
CREATE TABLE public.library_albums (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  library_id uuid NOT NULL,
  album_id uuid NOT NULL,
  added_at timestamp with time zone NOT NULL DEFAULT now(),
  added_by uuid NOT NULL,
  notes text,
  is_favorite boolean NOT NULL DEFAULT false,
  CONSTRAINT library_albums_pkey PRIMARY KEY (id),
  CONSTRAINT library_albums_library_album_key UNIQUE (library_id, album_id),
  CONSTRAINT library_albums_added_by_fkey FOREIGN KEY (added_by) REFERENCES users(id) ON DELETE CASCADE,
  CONSTRAINT library_albums_album_id_fkey FOREIGN KEY (album_id) REFERENCES albums(id) ON DELETE CASCADE,
  CONSTRAINT library_albums_library_id_fkey FOREIGN KEY (library_id) REFERENCES libraries(id) ON DELETE CASCADE
);
CREATE TABLE public.library_invitations (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  library_id uuid NOT NULL,
  invited_email text NOT NULL,
  invited_user_id uuid,
  role library_role NOT NULL DEFAULT 'viewer'::library_role,
  status invitation_status NOT NULL DEFAULT 'pending'::invitation_status,
  token text NOT NULL,
  invited_by uuid NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  expires_at timestamp with time zone NOT NULL DEFAULT (now() + '7 days'::interval),
  accepted_at timestamp with time zone,
  finalized_user_id uuid,
  CONSTRAINT library_invitations_pkey PRIMARY KEY (id),
  CONSTRAINT library_invitations_token_key UNIQUE (token),
  CONSTRAINT library_invitations_finalized_user_id_fkey FOREIGN KEY (finalized_user_id) REFERENCES users(id) ON DELETE SET NULL,
  CONSTRAINT library_invitations_invited_by_fkey FOREIGN KEY (invited_by) REFERENCES users(id) ON DELETE CASCADE,
  CONSTRAINT library_invitations_invited_user_id_fkey FOREIGN KEY (invited_user_id) REFERENCES users(id) ON DELETE SET NULL,
  CONSTRAINT library_invitations_library_id_fkey FOREIGN KEY (library_id) REFERENCES libraries(id) ON DELETE CASCADE
);
CREATE TABLE public.library_members (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  library_id uuid NOT NULL,
  user_id uuid NOT NULL,
  role library_role NOT NULL DEFAULT 'viewer'::library_role,
  joined_at timestamp with time zone NOT NULL DEFAULT now(),
  invited_by uuid,
  CONSTRAINT library_members_pkey PRIMARY KEY (id),
  CONSTRAINT library_members_library_user_key UNIQUE (library_id, user_id),
  CONSTRAINT library_members_invited_by_fkey FOREIGN KEY (invited_by) REFERENCES users(id) ON DELETE SET NULL,
  CONSTRAINT library_members_library_id_fkey FOREIGN KEY (library_id) REFERENCES libraries(id) ON DELETE CASCADE,
  CONSTRAINT library_members_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
CREATE TABLE public.listening_history (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  library_album_id uuid NOT NULL,
  played_at timestamp with time zone NOT NULL DEFAULT now(),
  play_duration_seconds integer,
  completed_side record_side,
  device_id uuid,
  CONSTRAINT listening_history_pkey PRIMARY KEY (id),
  CONSTRAINT listening_history_device_id_fkey FOREIGN KEY (device_id) REFERENCES consumer_devices(id) ON DELETE SET NULL,
  CONSTRAINT listening_history_library_album_id_fkey FOREIGN KEY (library_album_id) REFERENCES library_albums(id) ON DELETE CASCADE,
  CONSTRAINT listening_history_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
CREATE TABLE public.machine_macros (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  name text NOT NULL,
  description text,
  machine_type text NOT NULL,
  icon_name text NOT NULL,
  gcode_commands text NOT NULL,
  execution_order integer NOT NULL DEFAULT 1,
  is_active boolean NOT NULL DEFAULT true,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT machine_macros_pkey PRIMARY KEY (id),
  CONSTRAINT non_empty_gcode CHECK (length(TRIM(BOTH FROM gcode_commands)) > 0),
  CONSTRAINT non_empty_icon CHECK (length(TRIM(BOTH FROM icon_name)) > 0),
  CONSTRAINT non_empty_name CHECK (length(TRIM(BOTH FROM name)) > 0),
  CONSTRAINT positive_execution_order CHECK (execution_order > 0),
  CONSTRAINT valid_machine_type CHECK (machine_type = ANY (ARRAY['cnc'::text, 'laser'::text]))
);
CREATE TABLE public.notification_delivery_log (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  notification_type text NOT NULL,
  source_id uuid,
  token_id uuid,
  status text NOT NULL,
  error_message text,
  sent_at timestamp with time zone,
  delivered_at timestamp with time zone,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT notification_delivery_log_pkey PRIMARY KEY (id),
  CONSTRAINT notification_delivery_log_token_id_fkey FOREIGN KEY (token_id) REFERENCES push_notification_tokens(id) ON DELETE SET NULL,
  CONSTRAINT notification_delivery_log_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  CONSTRAINT notification_delivery_log_status_check CHECK (status = ANY (ARRAY['pending'::text, 'sent'::text, 'failed'::text, 'delivered'::text]))
);
CREATE TABLE public.notification_preferences (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  now_playing_enabled boolean NOT NULL DEFAULT true,
  flip_reminders_enabled boolean NOT NULL DEFAULT true,
  device_offline_enabled boolean NOT NULL DEFAULT true,
  device_online_enabled boolean NOT NULL DEFAULT true,
  battery_low_enabled boolean NOT NULL DEFAULT true,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT notification_preferences_pkey PRIMARY KEY (id),
  CONSTRAINT notification_preferences_user_unique UNIQUE (user_id),
  CONSTRAINT notification_preferences_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
CREATE TABLE public.now_playing_events (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  unit_id text NOT NULL,
  epc text NOT NULL,
  event_type text NOT NULL,
  rssi integer,
  duration_ms integer,
  timestamp timestamp with time zone NOT NULL DEFAULT now(),
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT now_playing_events_pkey PRIMARY KEY (id),
  CONSTRAINT now_playing_events_event_type_check CHECK (event_type = ANY (ARRAY['placed'::text, 'removed'::text]))
);
CREATE TABLE public.order_line_items (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  order_id uuid NOT NULL,
  product_id uuid,
  variant_id uuid,
  shopify_product_id character varying(255) NOT NULL,
  shopify_variant_id character varying(255) NOT NULL,
  title character varying(255) NOT NULL,
  quantity integer NOT NULL DEFAULT 1,
  price character varying(50),
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT order_line_items_pkey PRIMARY KEY (id),
  CONSTRAINT order_line_items_order_id_fkey FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE,
  CONSTRAINT order_line_items_product_id_fkey FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE SET NULL,
  CONSTRAINT order_line_items_variant_id_fkey FOREIGN KEY (variant_id) REFERENCES product_variants(id) ON DELETE SET NULL
);
CREATE TABLE public.orders (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  shopify_order_id character varying(255) NOT NULL,
  shopify_order_number character varying(50) NOT NULL,
  customer_id uuid,
  order_date timestamp with time zone NOT NULL,
  status character varying(50) NOT NULL,
  fulfillment_status character varying(50),
  assigned_unit_id uuid,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT orders_pkey PRIMARY KEY (id),
  CONSTRAINT orders_shopify_order_id_key UNIQUE (shopify_order_id),
  CONSTRAINT orders_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES customers(id) ON DELETE SET NULL,
  CONSTRAINT orders_units_fkey FOREIGN KEY (assigned_unit_id) REFERENCES units(id) ON DELETE SET NULL
);
CREATE TABLE public.permissions (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  name text NOT NULL,
  description text,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT permissions_pkey PRIMARY KEY (id),
  CONSTRAINT permissions_name_key UNIQUE (name)
);
CREATE TABLE public.product_device_types (
  product_id uuid NOT NULL,
  device_type_id uuid NOT NULL,
  quantity integer NOT NULL DEFAULT 1,
  CONSTRAINT product_device_types_pkey PRIMARY KEY (product_id, device_type_id),
  CONSTRAINT product_device_types_device_type_id_fkey FOREIGN KEY (device_type_id) REFERENCES device_types(id) ON DELETE CASCADE,
  CONSTRAINT product_device_types_product_id_fkey FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE,
  CONSTRAINT positive_quantity CHECK (quantity > 0)
);
CREATE TABLE public.product_variants (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  product_id uuid NOT NULL,
  shopify_variant_id text NOT NULL,
  sku text NOT NULL,
  name text NOT NULL,
  option1_name text,
  option1_value text,
  option2_name text,
  option2_value text,
  option3_name text,
  option3_value text,
  price numeric(10,2) NOT NULL,
  is_active boolean NOT NULL DEFAULT true,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT product_variants_pkey PRIMARY KEY (id),
  CONSTRAINT product_variants_shopify_variant_id_key UNIQUE (shopify_variant_id),
  CONSTRAINT product_variants_product_id_fkey FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE
);
CREATE TABLE public.production_steps (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  product_id uuid NOT NULL,
  name text NOT NULL,
  description text,
  step_order integer NOT NULL,
  file_url text,
  file_name text,
  file_type text,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  generate_label boolean NOT NULL DEFAULT false,
  label_text text,
  step_type step_type NOT NULL DEFAULT 'general'::step_type,
  engrave_qr boolean NOT NULL DEFAULT false,
  qr_x_offset numeric(10,3),
  qr_y_offset numeric(10,3),
  qr_size numeric(10,3),
  qr_power_percent integer,
  qr_speed_mm_min integer,
  firmware_version_id uuid,
  provisioning_manifest jsonb,
  CONSTRAINT production_steps_pkey PRIMARY KEY (id),
  CONSTRAINT production_steps_firmware_version_id_fkey FOREIGN KEY (firmware_version_id) REFERENCES firmware(id) ON DELETE SET NULL,
  CONSTRAINT production_steps_product_id_fkey FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE,
  CONSTRAINT positive_step_order CHECK (step_order > 0),
  CONSTRAINT qr_power_range CHECK (qr_power_percent IS NULL OR qr_power_percent >= 0 AND qr_power_percent <= 100),
  CONSTRAINT qr_size_positive CHECK (qr_size IS NULL OR qr_size > 0::numeric),
  CONSTRAINT qr_speed_positive CHECK (qr_speed_mm_min IS NULL OR qr_speed_mm_min > 0)
);
CREATE TABLE public.production_units (
  id uuid NOT NULL DEFAULT extensions.uuid_generate_v4(),
  uuid uuid NOT NULL DEFAULT extensions.uuid_generate_v4(),
  unit_id character varying(100) NOT NULL,
  product_id uuid NOT NULL,
  variant_id uuid NOT NULL,
  shopify_order_id character varying(255),
  shopify_order_number character varying(50),
  customer_name character varying(255),
  current_owner_id uuid,
  qr_code_url text NOT NULL,
  production_started_at timestamp with time zone,
  production_completed_at timestamp with time zone,
  is_completed boolean DEFAULT false,
  created_at timestamp with time zone DEFAULT now(),
  created_by uuid NOT NULL,
  mac_address character varying(17),
  CONSTRAINT production_units_pkey PRIMARY KEY (id),
  CONSTRAINT production_units_unit_id_key UNIQUE (unit_id),
  CONSTRAINT production_units_uuid_key UNIQUE (uuid),
  CONSTRAINT production_units_created_by_fkey FOREIGN KEY (created_by) REFERENCES users(id) ON DELETE RESTRICT,
  CONSTRAINT production_units_current_owner_id_fkey FOREIGN KEY (current_owner_id) REFERENCES users(id) ON DELETE SET NULL,
  CONSTRAINT production_units_product_id_fkey FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE RESTRICT,
  CONSTRAINT production_units_variant_id_fkey FOREIGN KEY (variant_id) REFERENCES product_variants(id) ON DELETE RESTRICT,
  CONSTRAINT valid_mac_address_format CHECK (mac_address IS NULL OR mac_address::text ~ '^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$'::text)
);
CREATE TABLE public.products (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  shopify_product_id text NOT NULL,
  shopify_product_handle text NOT NULL,
  name text NOT NULL,
  product_code text NOT NULL,
  description text,
  is_active boolean NOT NULL DEFAULT true,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  last_synced_at timestamp with time zone,
  short_name character varying(50),
  CONSTRAINT products_pkey PRIMARY KEY (id),
  CONSTRAINT products_product_code_key UNIQUE (product_code),
  CONSTRAINT products_shopify_product_id_key UNIQUE (shopify_product_id)
);
CREATE TABLE public.push_notification_tokens (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  token text NOT NULL,
  platform text NOT NULL,
  device_identifier text NOT NULL,
  app_version text,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  last_used_at timestamp with time zone,
  is_active boolean NOT NULL DEFAULT true,
  CONSTRAINT push_notification_tokens_pkey PRIMARY KEY (id),
  CONSTRAINT push_tokens_user_device_key UNIQUE (user_id, device_identifier),
  CONSTRAINT push_notification_tokens_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  CONSTRAINT push_notification_tokens_platform_check CHECK (platform = ANY (ARRAY['ios'::text, 'android'::text]))
);
CREATE TABLE public.rfid_tag_rolls (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  label_width_mm numeric(6,2) NOT NULL,
  label_height_mm numeric(6,2) NOT NULL,
  label_count integer NOT NULL,
  status character varying(20) NOT NULL DEFAULT 'writing'::character varying,
  last_printed_position integer NOT NULL DEFAULT 0,
  manufacturer_url text,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  created_by uuid,
  CONSTRAINT rfid_tag_rolls_pkey PRIMARY KEY (id),
  CONSTRAINT rfid_tag_rolls_created_by_fkey FOREIGN KEY (created_by) REFERENCES users(id),
  CONSTRAINT positive_dimensions CHECK (label_width_mm > 0::numeric AND label_height_mm > 0::numeric),
  CONSTRAINT positive_label_count CHECK (label_count > 0),
  CONSTRAINT valid_printed_position CHECK (last_printed_position >= 0),
  CONSTRAINT valid_roll_status CHECK (status::text = ANY (ARRAY['writing'::character varying, 'ready_to_print'::character varying, 'printing'::character varying, 'completed'::character varying]::text[]))
);
CREATE TABLE public.rfid_tags (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  epc_identifier character varying(24) NOT NULL,
  tid character varying(48),
  status character varying(20) NOT NULL DEFAULT 'generated'::character varying,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  written_at timestamp with time zone,
  locked_at timestamp with time zone,
  created_by uuid,
  library_album_id uuid,
  associated_at timestamp with time zone,
  associated_by uuid,
  last_seen_at timestamp with time zone,
  roll_id uuid,
  roll_position integer,
  CONSTRAINT rfid_tags_pkey PRIMARY KEY (id),
  CONSTRAINT rfid_tags_epc_identifier_key UNIQUE (epc_identifier),
  CONSTRAINT rfid_tags_associated_by_fkey FOREIGN KEY (associated_by) REFERENCES users(id) ON DELETE SET NULL,
  CONSTRAINT rfid_tags_created_by_fkey FOREIGN KEY (created_by) REFERENCES users(id),
  CONSTRAINT rfid_tags_library_album_id_fkey FOREIGN KEY (library_album_id) REFERENCES library_albums(id) ON DELETE SET NULL,
  CONSTRAINT rfid_tags_roll_id_fkey FOREIGN KEY (roll_id) REFERENCES rfid_tag_rolls(id) ON DELETE SET NULL,
  CONSTRAINT valid_roll_position CHECK (roll_position IS NULL OR roll_position > 0),
  CONSTRAINT valid_status CHECK (status::text = ANY (ARRAY['generated'::character varying, 'written'::character varying, 'active'::character varying, 'retired'::character varying]::text[]))
);
CREATE TABLE public.step_files (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  step_id uuid NOT NULL,
  file_id uuid NOT NULL,
  execution_order integer NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT step_files_pkey PRIMARY KEY (id),
  CONSTRAINT unique_step_execution_order UNIQUE (step_id, execution_order),
  CONSTRAINT unique_step_file UNIQUE (step_id, file_id),
  CONSTRAINT step_files_file_id_fkey FOREIGN KEY (file_id) REFERENCES files(id) ON DELETE CASCADE,
  CONSTRAINT step_files_step_id_fkey FOREIGN KEY (step_id) REFERENCES production_steps(id) ON DELETE CASCADE,
  CONSTRAINT positive_execution_order CHECK (execution_order > 0)
);
CREATE TABLE public.step_gcode_files (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  step_id uuid NOT NULL,
  gcode_file_id uuid NOT NULL,
  execution_order integer NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT step_gcode_files_pkey PRIMARY KEY (id),
  CONSTRAINT unique_step_gcode UNIQUE (step_id, gcode_file_id),
  CONSTRAINT unique_step_order UNIQUE (step_id, execution_order),
  CONSTRAINT step_gcode_files_gcode_file_id_fkey FOREIGN KEY (gcode_file_id) REFERENCES gcode_files(id) ON DELETE CASCADE,
  CONSTRAINT step_gcode_files_step_id_fkey FOREIGN KEY (step_id) REFERENCES production_steps(id) ON DELETE CASCADE,
  CONSTRAINT positive_execution_order CHECK (execution_order > 0)
);
CREATE TABLE public.step_labels (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  step_id uuid NOT NULL,
  label_text text NOT NULL,
  label_order integer NOT NULL DEFAULT 1,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT step_labels_pkey PRIMARY KEY (id),
  CONSTRAINT step_labels_step_id_fkey FOREIGN KEY (step_id) REFERENCES production_steps(id) ON DELETE CASCADE,
  CONSTRAINT positive_label_order CHECK (label_order > 0)
);
CREATE TABLE public.step_timers (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  step_id uuid NOT NULL,
  timer_name text NOT NULL,
  duration_minutes integer NOT NULL,
  timer_order integer NOT NULL DEFAULT 1,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT step_timers_pkey PRIMARY KEY (id),
  CONSTRAINT step_timers_step_id_fkey FOREIGN KEY (step_id) REFERENCES production_steps(id) ON DELETE CASCADE,
  CONSTRAINT positive_duration CHECK (duration_minutes > 0),
  CONSTRAINT positive_timer_order CHECK (timer_order > 0)
);
CREATE TABLE public.thread_credentials (
  id uuid NOT NULL DEFAULT extensions.uuid_generate_v4(),
  unit_id uuid NOT NULL,
  network_name character varying(16) NOT NULL,
  pan_id integer NOT NULL,
  channel integer NOT NULL,
  network_key character varying(32) NOT NULL,
  extended_pan_id character varying(16) NOT NULL,
  mesh_local_prefix character varying(16) NOT NULL,
  pskc character varying(32) NOT NULL,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now(),
  CONSTRAINT thread_credentials_pkey PRIMARY KEY (id),
  CONSTRAINT thread_credentials_unit_id_key UNIQUE (unit_id),
  CONSTRAINT thread_credentials_units_fkey FOREIGN KEY (unit_id) REFERENCES units(id) ON DELETE CASCADE,
  CONSTRAINT valid_channel CHECK (channel >= 11 AND channel <= 26),
  CONSTRAINT valid_extended_pan_id_length CHECK (length(extended_pan_id::text) = 16 AND extended_pan_id::text ~ '^[0-9a-fA-F]+$'::text),
  CONSTRAINT valid_mesh_local_prefix_length CHECK (length(mesh_local_prefix::text) = 16 AND mesh_local_prefix::text ~ '^[0-9a-fA-F]+$'::text),
  CONSTRAINT valid_network_key_length CHECK (length(network_key::text) = 32 AND network_key::text ~ '^[0-9a-fA-F]+$'::text),
  CONSTRAINT valid_pan_id CHECK (pan_id >= 0 AND pan_id <= 65534),
  CONSTRAINT valid_pskc_length CHECK (length(pskc::text) = 32 AND pskc::text ~ '^[0-9a-fA-F]+$'::text)
);
CREATE TABLE public.unit_step_completions (
  id uuid NOT NULL DEFAULT extensions.uuid_generate_v4(),
  unit_id uuid NOT NULL,
  step_id uuid NOT NULL,
  completed_at timestamp with time zone DEFAULT now(),
  completed_by uuid NOT NULL,
  notes text,
  CONSTRAINT unit_step_completions_pkey PRIMARY KEY (id),
  CONSTRAINT unit_step_completions_unit_id_step_id_key UNIQUE (unit_id, step_id),
  CONSTRAINT unit_step_completions_completed_by_fkey FOREIGN KEY (completed_by) REFERENCES users(id) ON DELETE RESTRICT,
  CONSTRAINT unit_step_completions_step_id_fkey FOREIGN KEY (step_id) REFERENCES production_steps(id) ON DELETE CASCADE,
  CONSTRAINT unit_step_completions_units_fkey FOREIGN KEY (unit_id) REFERENCES units(id) ON DELETE CASCADE
);
CREATE TABLE public.unit_timers (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  unit_id uuid NOT NULL,
  step_timer_id uuid NOT NULL,
  started_at timestamp with time zone NOT NULL,
  expires_at timestamp with time zone NOT NULL,
  completed_at timestamp with time zone,
  status text NOT NULL DEFAULT 'active'::text,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT unit_timers_pkey PRIMARY KEY (id),
  CONSTRAINT unit_timers_step_timer_id_fkey FOREIGN KEY (step_timer_id) REFERENCES step_timers(id) ON DELETE CASCADE,
  CONSTRAINT unit_timers_units_fkey FOREIGN KEY (unit_id) REFERENCES units(id) ON DELETE CASCADE,
  CONSTRAINT valid_status CHECK (status = ANY (ARRAY['active'::text, 'completed'::text, 'cancelled'::text]))
);
CREATE TABLE public.units (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  serial_number character varying(100),
  product_id uuid,
  variant_id uuid,
  order_id uuid,
  factory_provisioned_at timestamp with time zone,
  factory_provisioned_by uuid,
  consumer_user_id uuid,
  consumer_name character varying(255),
  status unit_status DEFAULT 'in_production'::unit_status,
  production_started_at timestamp with time zone,
  production_completed_at timestamp with time zone,
  is_completed boolean DEFAULT false,
  qr_code_url text,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now(),
  created_by uuid,
  battery_level integer,
  is_charging boolean,
  last_seen_at timestamp with time zone,
  is_online boolean DEFAULT false,
  wifi_rssi integer,
  temperature_c numeric,
  humidity_pct numeric,
  firmware_version text,
  CONSTRAINT units_pkey PRIMARY KEY (id),
  CONSTRAINT units_serial_number_key UNIQUE (serial_number),
  CONSTRAINT units_created_by_fkey FOREIGN KEY (created_by) REFERENCES users(id),
  CONSTRAINT units_factory_provisioned_by_fkey FOREIGN KEY (factory_provisioned_by) REFERENCES users(id),
  CONSTRAINT units_order_id_fkey FOREIGN KEY (order_id) REFERENCES orders(id),
  CONSTRAINT units_product_id_fkey FOREIGN KEY (product_id) REFERENCES products(id),
  CONSTRAINT units_variant_id_fkey FOREIGN KEY (variant_id) REFERENCES product_variants(id),
  CONSTRAINT units_battery_level_check CHECK (battery_level IS NULL OR battery_level >= 0 AND battery_level <= 100)
);
CREATE TABLE public.user_now_playing_notifications (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  source_event_id uuid NOT NULL,
  unit_id text NOT NULL,
  epc text NOT NULL,
  event_type text NOT NULL,
  library_album_id uuid,
  album_title text,
  album_artist text,
  cover_image_url text,
  library_id uuid,
  library_name text,
  device_id uuid,
  device_name text,
  event_timestamp timestamp with time zone NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT user_now_playing_notifications_pkey PRIMARY KEY (id),
  CONSTRAINT user_notifications_event_user_key UNIQUE (source_event_id, user_id),
  CONSTRAINT user_now_playing_notifications_device_id_fkey FOREIGN KEY (device_id) REFERENCES consumer_devices(id) ON DELETE SET NULL,
  CONSTRAINT user_now_playing_notifications_library_album_id_fkey FOREIGN KEY (library_album_id) REFERENCES library_albums(id) ON DELETE SET NULL,
  CONSTRAINT user_now_playing_notifications_library_id_fkey FOREIGN KEY (library_id) REFERENCES libraries(id) ON DELETE SET NULL,
  CONSTRAINT user_now_playing_notifications_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  CONSTRAINT user_now_playing_notifications_event_type_check CHECK (event_type = ANY (ARRAY['placed'::text, 'removed'::text]))
);
CREATE TABLE public.user_permissions (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  permission_id uuid NOT NULL,
  granted_at timestamp with time zone NOT NULL DEFAULT now(),
  granted_by uuid,
  CONSTRAINT user_permissions_pkey PRIMARY KEY (id),
  CONSTRAINT user_permissions_user_id_permission_id_key UNIQUE (user_id, permission_id),
  CONSTRAINT user_permissions_granted_by_fkey FOREIGN KEY (granted_by) REFERENCES users(id),
  CONSTRAINT user_permissions_permission_id_fkey FOREIGN KEY (permission_id) REFERENCES permissions(id) ON DELETE CASCADE,
  CONSTRAINT user_permissions_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
CREATE TABLE public.users (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  google_id text,
  email text NOT NULL,
  full_name text,
  is_admin boolean NOT NULL DEFAULT false,
  is_active boolean NOT NULL DEFAULT true,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  last_login timestamp with time zone,
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  avatar_url text,
  preferences jsonb DEFAULT '{}'::jsonb,
  auth_user_id uuid,
  CONSTRAINT users_pkey PRIMARY KEY (id),
  CONSTRAINT users_email_key UNIQUE (email),
  CONSTRAINT users_google_id_key UNIQUE (google_id),
  CONSTRAINT users_auth_user_id_fkey FOREIGN KEY (auth_user_id) REFERENCES auth.users(id) ON DELETE SET NULL
);
CREATE INDEX idx_album_locations_current ON public.album_locations USING btree (device_id, library_album_id) WHERE (removed_at IS NULL);
CREATE INDEX idx_album_locations_detected_at ON public.album_locations USING btree (detected_at DESC);
CREATE INDEX idx_album_locations_device_id ON public.album_locations USING btree (device_id);
CREATE INDEX idx_album_locations_library_album_id ON public.album_locations USING btree (library_album_id);
CREATE INDEX idx_albums_artist ON public.albums USING btree (artist);
CREATE INDEX idx_albums_created_at ON public.albums USING btree (created_at);
CREATE INDEX idx_albums_discogs_id ON public.albums USING btree (discogs_id);
CREATE INDEX idx_albums_genres ON public.albums USING gin (genres);
CREATE INDEX idx_albums_search ON public.albums USING gin (to_tsvector('english'::regconfig, ((((title || ' '::text) || artist) || ' '::text) || COALESCE(label, ''::text))));
CREATE INDEX idx_albums_styles ON public.albums USING gin (styles);
CREATE INDEX idx_albums_title ON public.albums USING btree (title);
CREATE INDEX idx_albums_year ON public.albums USING btree (year);
CREATE INDEX idx_capabilities_active ON public.capabilities USING btree (is_active) WHERE (is_active = true);
CREATE INDEX idx_capabilities_name ON public.capabilities USING btree (name);
CREATE INDEX idx_consumer_devices_device_type ON public.consumer_devices USING btree (device_type);
CREATE INDEX idx_consumer_devices_last_seen_at ON public.consumer_devices USING btree (last_seen_at DESC);
CREATE INDEX idx_consumer_devices_production_unit_id ON public.consumer_devices USING btree (production_unit_id);
CREATE INDEX idx_consumer_devices_serial_number ON public.consumer_devices USING btree (serial_number);
CREATE INDEX idx_consumer_devices_status ON public.consumer_devices USING btree (status);
CREATE INDEX idx_consumer_devices_user_id ON public.consumer_devices USING btree (user_id);
CREATE INDEX idx_customers_email ON public.customers USING btree (email);
CREATE INDEX idx_customers_shopify_id ON public.customers USING btree (shopify_customer_id);
CREATE INDEX idx_device_commands_created ON public.device_commands USING btree (created_at DESC);
CREATE INDEX idx_device_commands_mac ON public.device_commands USING btree (mac_address);
CREATE INDEX idx_device_commands_pending ON public.device_commands USING btree (mac_address, status) WHERE (status = 'pending'::text);
CREATE INDEX idx_device_commands_status ON public.device_commands USING btree (status);
CREATE INDEX idx_device_heartbeats_created_at ON public.device_heartbeats USING btree (created_at);
CREATE INDEX idx_heartbeats_command_id ON public.device_heartbeats USING btree (command_id) WHERE (command_id IS NOT NULL);
CREATE INDEX idx_heartbeats_telemetry ON public.device_heartbeats USING gin (telemetry jsonb_path_ops);
CREATE INDEX idx_heartbeats_type ON public.device_heartbeats USING btree (type) WHERE (type <> 'status'::text);
CREATE INDEX idx_heartbeats_unit_id ON public.device_heartbeats USING btree (unit_id);
CREATE INDEX idx_device_status_notifications_type_sent ON public.device_status_notifications USING btree (notification_type, last_sent_at DESC);
CREATE INDEX idx_device_status_notifications_unit ON public.device_status_notifications USING btree (unit_id);
CREATE INDEX idx_device_status_notifications_user ON public.device_status_notifications USING btree (user_id);
CREATE INDEX idx_device_type_capabilities_capability ON public.device_type_capabilities USING btree (capability_id);
CREATE INDEX idx_device_type_capabilities_device_type ON public.device_type_capabilities USING btree (device_type_id);
CREATE INDEX idx_device_types_active ON public.device_types USING btree (is_active);
CREATE INDEX idx_device_types_name ON public.device_types USING btree (name);
CREATE UNIQUE INDEX idx_device_types_slug ON public.device_types USING btree (slug);
CREATE INDEX idx_devices_consumer_provisioned_by ON public.devices USING btree (consumer_provisioned_by);
CREATE INDEX idx_devices_device_type_slug ON public.devices USING btree (device_type_slug);
CREATE INDEX idx_devices_firmware_id ON public.devices USING btree (firmware_id) WHERE (firmware_id IS NOT NULL);
CREATE INDEX idx_devices_last_seen ON public.devices USING btree (last_seen_at DESC) WHERE (last_seen_at IS NOT NULL);
CREATE INDEX idx_devices_latest_telemetry ON public.devices USING gin (latest_telemetry);
CREATE INDEX idx_devices_mac_address ON public.devices USING btree (mac_address);
CREATE INDEX idx_devices_provision_data ON public.devices USING gin (provision_data);
CREATE INDEX idx_devices_status ON public.devices USING btree (status);
CREATE INDEX idx_devices_unit_id ON public.devices USING btree (unit_id) WHERE (unit_id IS NOT NULL);
CREATE INDEX idx_files_created_at ON public.files USING btree (created_at DESC);
CREATE INDEX idx_files_mime_type ON public.files USING btree (mime_type);
CREATE INDEX idx_files_name ON public.files USING btree (file_name);
CREATE INDEX idx_firmware_versions_created_at ON public.firmware USING btree (created_at DESC);
CREATE INDEX idx_firmware_versions_device_type ON public.firmware USING btree (device_type_id);
CREATE INDEX idx_firmware_versions_production ON public.firmware USING btree (is_production_ready);
CREATE INDEX idx_firmware_versions_version ON public.firmware USING btree (version);
CREATE INDEX idx_firmware_files_firmware_id ON public.firmware_files USING btree (firmware_id);
CREATE INDEX idx_firmware_files_soc_type ON public.firmware_files USING btree (soc_type);
CREATE INDEX idx_gcode_files_github_path ON public.gcode_files USING btree (github_path);
CREATE INDEX idx_gcode_files_machine_type ON public.gcode_files USING btree (machine_type);
CREATE INDEX idx_libraries_created_at ON public.libraries USING btree (created_at);
CREATE INDEX idx_libraries_created_by ON public.libraries USING btree (created_by);
CREATE INDEX idx_libraries_name ON public.libraries USING btree (name);
CREATE INDEX idx_library_albums_added_at ON public.library_albums USING btree (added_at DESC);
CREATE INDEX idx_library_albums_added_by ON public.library_albums USING btree (added_by);
CREATE INDEX idx_library_albums_album_id ON public.library_albums USING btree (album_id);
CREATE INDEX idx_library_albums_is_favorite ON public.library_albums USING btree (is_favorite) WHERE (is_favorite = true);
CREATE INDEX idx_library_albums_library_id ON public.library_albums USING btree (library_id);
CREATE INDEX idx_library_invitations_email ON public.library_invitations USING btree (invited_email);
CREATE INDEX idx_library_invitations_invited_user ON public.library_invitations USING btree (invited_user_id) WHERE (invited_user_id IS NOT NULL);
CREATE INDEX idx_library_invitations_library ON public.library_invitations USING btree (library_id);
CREATE INDEX idx_library_invitations_pending ON public.library_invitations USING btree (status) WHERE (status = 'pending'::invitation_status);
CREATE INDEX idx_library_invitations_token ON public.library_invitations USING btree (token);
CREATE INDEX idx_library_members_library_id ON public.library_members USING btree (library_id);
CREATE INDEX idx_library_members_role ON public.library_members USING btree (role);
CREATE INDEX idx_library_members_user_id ON public.library_members USING btree (user_id);
CREATE INDEX idx_listening_history_device_id ON public.listening_history USING btree (device_id);
CREATE INDEX idx_listening_history_library_album_id ON public.listening_history USING btree (library_album_id);
CREATE INDEX idx_listening_history_played_at ON public.listening_history USING btree (played_at DESC);
CREATE INDEX idx_listening_history_user_id ON public.listening_history USING btree (user_id);
CREATE INDEX idx_listening_history_user_recent ON public.listening_history USING btree (user_id, played_at DESC);
CREATE INDEX idx_machine_macros_execution_order ON public.machine_macros USING btree (execution_order);
CREATE INDEX idx_machine_macros_machine_type_active ON public.machine_macros USING btree (machine_type, is_active);
CREATE INDEX idx_delivery_log_source ON public.notification_delivery_log USING btree (source_id);
CREATE INDEX idx_delivery_log_user_recent ON public.notification_delivery_log USING btree (user_id, created_at DESC);
CREATE INDEX idx_notification_preferences_user ON public.notification_preferences USING btree (user_id);
CREATE INDEX idx_now_playing_events_epc ON public.now_playing_events USING btree (epc);
CREATE INDEX idx_now_playing_events_timestamp ON public.now_playing_events USING btree ("timestamp" DESC);
CREATE INDEX idx_now_playing_events_unit_id ON public.now_playing_events USING btree (unit_id);
CREATE INDEX idx_now_playing_events_unit_timestamp ON public.now_playing_events USING btree (unit_id, "timestamp" DESC);
CREATE INDEX idx_order_line_items_order_id ON public.order_line_items USING btree (order_id);
CREATE INDEX idx_order_line_items_product_id ON public.order_line_items USING btree (product_id);
CREATE INDEX idx_order_line_items_shopify_product_id ON public.order_line_items USING btree (shopify_product_id);
CREATE INDEX idx_order_line_items_shopify_variant_id ON public.order_line_items USING btree (shopify_variant_id);
CREATE INDEX idx_order_line_items_variant_id ON public.order_line_items USING btree (variant_id);
CREATE INDEX idx_orders_assigned_unit_id ON public.orders USING btree (assigned_unit_id);
CREATE INDEX idx_orders_customer_id ON public.orders USING btree (customer_id);
CREATE INDEX idx_orders_fulfillment_status ON public.orders USING btree (fulfillment_status);
CREATE INDEX idx_orders_order_date ON public.orders USING btree (order_date);
CREATE INDEX idx_orders_shopify_id ON public.orders USING btree (shopify_order_id);
CREATE INDEX idx_orders_shopify_order_number ON public.orders USING btree (shopify_order_number);
CREATE INDEX idx_orders_status ON public.orders USING btree (status);
CREATE INDEX idx_product_devices_device ON public.product_device_types USING btree (device_type_id);
CREATE INDEX idx_product_devices_product ON public.product_device_types USING btree (product_id);
CREATE INDEX idx_variants_active ON public.product_variants USING btree (is_active);
CREATE INDEX idx_variants_product_id ON public.product_variants USING btree (product_id);
CREATE INDEX idx_variants_shopify_id ON public.product_variants USING btree (shopify_variant_id);
CREATE INDEX idx_variants_sku ON public.product_variants USING btree (sku);
CREATE INDEX idx_production_steps_firmware_version ON public.production_steps USING btree (firmware_version_id);
CREATE INDEX idx_production_steps_generate_label ON public.production_steps USING btree (generate_label) WHERE (generate_label = true);
CREATE INDEX idx_production_steps_order ON public.production_steps USING btree (step_order);
CREATE INDEX idx_production_steps_product_id ON public.production_steps USING btree (product_id);
CREATE INDEX idx_production_steps_step_type ON public.production_steps USING btree (step_type);
CREATE INDEX idx_production_units_created_at ON public.production_units USING btree (created_at);
CREATE INDEX idx_production_units_is_completed ON public.production_units USING btree (is_completed);
CREATE INDEX idx_production_units_mac_address ON public.production_units USING btree (mac_address);
CREATE INDEX idx_production_units_product_id ON public.production_units USING btree (product_id);
CREATE INDEX idx_production_units_shopify_order_id ON public.production_units USING btree (shopify_order_id);
CREATE INDEX idx_production_units_unit_id ON public.production_units USING btree (unit_id);
CREATE INDEX idx_production_units_uuid ON public.production_units USING btree (uuid);
CREATE INDEX idx_production_units_variant_id ON public.production_units USING btree (variant_id);
CREATE INDEX idx_products_active ON public.products USING btree (is_active);
CREATE INDEX idx_products_code ON public.products USING btree (product_code);
CREATE INDEX idx_products_handle ON public.products USING btree (shopify_product_handle);
CREATE INDEX idx_products_shopify_id ON public.products USING btree (shopify_product_id);
CREATE INDEX idx_push_tokens_token ON public.push_notification_tokens USING btree (token);
CREATE INDEX idx_push_tokens_user_active ON public.push_notification_tokens USING btree (user_id) WHERE (is_active = true);
CREATE INDEX idx_rfid_tag_rolls_created ON public.rfid_tag_rolls USING btree (created_at DESC);
CREATE INDEX idx_rfid_tag_rolls_status ON public.rfid_tag_rolls USING btree (status);
CREATE INDEX idx_rfid_tags_created ON public.rfid_tags USING btree (created_at DESC);
CREATE INDEX idx_rfid_tags_epc ON public.rfid_tags USING btree (epc_identifier);
CREATE INDEX idx_rfid_tags_last_seen_at ON public.rfid_tags USING btree (last_seen_at DESC);
CREATE INDEX idx_rfid_tags_library_album_id ON public.rfid_tags USING btree (library_album_id);
CREATE INDEX idx_rfid_tags_roll ON public.rfid_tags USING btree (roll_id, roll_position);
CREATE INDEX idx_rfid_tags_status ON public.rfid_tags USING btree (status);
CREATE INDEX idx_step_files_execution_order ON public.step_files USING btree (step_id, execution_order);
CREATE INDEX idx_step_files_file_id ON public.step_files USING btree (file_id);
CREATE INDEX idx_step_files_step_id ON public.step_files USING btree (step_id);
CREATE INDEX idx_step_gcode_execution_order ON public.step_gcode_files USING btree (step_id, execution_order);
CREATE INDEX idx_step_gcode_file_id ON public.step_gcode_files USING btree (gcode_file_id);
CREATE INDEX idx_step_gcode_step_id ON public.step_gcode_files USING btree (step_id);
CREATE INDEX idx_step_labels_order ON public.step_labels USING btree (step_id, label_order);
CREATE INDEX idx_step_labels_step_id ON public.step_labels USING btree (step_id);
CREATE INDEX idx_step_timers_order ON public.step_timers USING btree (step_id, timer_order);
CREATE INDEX idx_step_timers_step_id ON public.step_timers USING btree (step_id);
CREATE INDEX idx_thread_credentials_unit_id ON public.thread_credentials USING btree (unit_id);
CREATE INDEX idx_unit_step_completions_completed_by ON public.unit_step_completions USING btree (completed_by);
CREATE INDEX idx_unit_step_completions_step_id ON public.unit_step_completions USING btree (step_id);
CREATE INDEX idx_unit_step_completions_unit_id ON public.unit_step_completions USING btree (unit_id);
CREATE INDEX idx_unit_timers_expires_at ON public.unit_timers USING btree (expires_at) WHERE (status = 'active'::text);
CREATE INDEX idx_unit_timers_status ON public.unit_timers USING btree (status);
CREATE INDEX idx_unit_timers_step_timer_id ON public.unit_timers USING btree (step_timer_id);
CREATE INDEX idx_unit_timers_unit_id ON public.unit_timers USING btree (unit_id);
CREATE INDEX idx_units_consumer_user_id ON public.units USING btree (consumer_user_id);
CREATE INDEX idx_units_factory_provisioned ON public.units USING btree (factory_provisioned_at) WHERE (factory_provisioned_at IS NOT NULL);
CREATE INDEX idx_units_is_completed ON public.units USING btree (is_completed);
CREATE INDEX idx_units_is_online ON public.units USING btree (is_online) WHERE (consumer_user_id IS NOT NULL);
CREATE INDEX idx_units_last_seen_at ON public.units USING btree (last_seen_at) WHERE (last_seen_at IS NOT NULL);
CREATE INDEX idx_units_order_id ON public.units USING btree (order_id) WHERE (order_id IS NOT NULL);
CREATE INDEX idx_units_product_id ON public.units USING btree (product_id);
CREATE INDEX idx_units_serial_number ON public.units USING btree (serial_number) WHERE (serial_number IS NOT NULL);
CREATE INDEX idx_units_status ON public.units USING btree (status);
CREATE INDEX idx_units_user_id ON public.units USING btree (consumer_user_id) WHERE (consumer_user_id IS NOT NULL);
CREATE INDEX idx_user_notifications_recent ON public.user_now_playing_notifications USING btree (created_at DESC);
CREATE INDEX idx_user_notifications_user_timestamp ON public.user_now_playing_notifications USING btree (user_id, event_timestamp DESC);
CREATE INDEX idx_user_permissions_permission_id ON public.user_permissions USING btree (permission_id);
CREATE INDEX idx_user_permissions_user_id ON public.user_permissions USING btree (user_id);
CREATE INDEX idx_users_auth_user_id ON public.users USING btree (auth_user_id);
CREATE INDEX idx_users_email ON public.users USING btree (email);
CREATE INDEX idx_users_google_id ON public.users USING btree (google_id);
CREATE OR REPLACE VIEW public.current_now_playing AS
 SELECT DISTINCT ON (unit_id) unit_id,
    epc,
    event_type,
    rssi,
    "timestamp" AS last_event_time,
        CASE
            WHEN event_type = 'placed'::text THEN true
            ELSE false
        END AS is_playing
   FROM now_playing_events
  ORDER BY unit_id, "timestamp" DESC;

CREATE OR REPLACE VIEW public.production_units_compat AS
 SELECT u.id,
    u.serial_number AS unit_id,
    u.product_id,
    u.variant_id,
    u.order_id,
    d.mac_address,
    u.qr_code_url,
    u.production_started_at,
    u.production_completed_at,
    u.is_completed,
    u.created_at,
    u.created_by
   FROM units u
     LEFT JOIN devices d ON d.unit_id = u.id;

CREATE OR REPLACE FUNCTION public.accept_invitation_by_token(p_token text, p_accepting_user_id uuid)
 RETURNS library_invitations
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_invitation library_invitations;
BEGIN
    -- Find and lock the invitation
    SELECT * INTO v_invitation
    FROM library_invitations
    WHERE token = p_token
    FOR UPDATE;

    IF v_invitation IS NULL THEN
        RAISE EXCEPTION 'Invitation not found';
    END IF;

    IF v_invitation.status != 'pending' THEN
        RAISE EXCEPTION 'Invitation is no longer pending (status: %)', v_invitation.status;
    END IF;

    IF v_invitation.expires_at < NOW() THEN
        -- Mark as expired
        UPDATE library_invitations SET status = 'expired' WHERE id = v_invitation.id;
        RAISE EXCEPTION 'Invitation has expired';
    END IF;

    -- Verify accepting user exists
    IF NOT EXISTS (SELECT 1 FROM users WHERE id = p_accepting_user_id) THEN
        RAISE EXCEPTION 'User not found';
    END IF;

    -- Check if user is already a member
    IF EXISTS (
        SELECT 1 FROM library_members
        WHERE library_id = v_invitation.library_id AND user_id = p_accepting_user_id
    ) THEN
        RAISE EXCEPTION 'User is already a member of this library';
    END IF;

    -- Update invitation
    UPDATE library_invitations
    SET
        status = 'accepted',
        accepted_at = NOW(),
        finalized_user_id = p_accepting_user_id
    WHERE id = v_invitation.id
    RETURNING * INTO v_invitation;

    -- Add user to library members
    INSERT INTO library_members (library_id, user_id, role, joined_at, invited_by)
    VALUES (v_invitation.library_id, p_accepting_user_id, v_invitation.role, NOW(), v_invitation.invited_by);

    RETURN v_invitation;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.associate_rfid_tag(p_epc text, p_library_album_id uuid, p_user_id uuid)
 RETURNS rfid_tags
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_tag rfid_tags;
BEGIN
    -- Update the existing tag with association info
    UPDATE rfid_tags
    SET
        library_album_id = p_library_album_id,
        associated_at = NOW(),
        associated_by = p_user_id,
        updated_at = NOW()
    WHERE epc_identifier = p_epc
    RETURNING * INTO v_tag;

    -- If tag doesn't exist, this is an error (tags must be created by admin app)
    IF v_tag IS NULL THEN
        RAISE EXCEPTION 'Tag with EPC % not found. Tags must be provisioned via admin app.', p_epc;
    END IF;

    RETURN v_tag;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.broadcast_device_command()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  channel_name TEXT;
BEGIN
  -- Replace colons with dashes for channel name
  channel_name := 'device:' || REPLACE(NEW.mac_address, ':', '-');

  -- Use Supabase Realtime broadcast
  PERFORM pg_notify(
    'realtime:broadcast',
    json_build_object(
      'topic', channel_name,
      'event', 'broadcast',
      'payload', json_build_object(
        'event', 'command',
        'payload', json_build_object(
          'id', NEW.id,
          'command', NEW.command,
          'capability', NEW.capability,
          'test_name', NEW.test_name,
          'parameters', NEW.parameters
        )
      )
    )::text
  );

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.can_edit_library(lib_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM library_members
        WHERE library_id = lib_id
        AND user_id = get_user_id_from_auth()
        AND role IN ('owner', 'editor')
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_old_heartbeats(retention_hours integer DEFAULT 24)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM device_heartbeats
  WHERE received_at < NOW() - (retention_hours || ' hours')::INTERVAL;

  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_old_notifications()
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM user_now_playing_notifications
    WHERE created_at < NOW() - INTERVAL '24 hours';

    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_library_invitation(p_library_id uuid, p_email text, p_role library_role, p_invited_by uuid)
 RETURNS library_invitations
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_invitation library_invitations;
    v_existing_user_id UUID;
    v_library_name TEXT;
BEGIN
    -- Normalize email to lowercase
    p_email := lower(trim(p_email));

    -- Validate email format
    IF p_email !~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$' THEN
        RAISE EXCEPTION 'Invalid email format';
    END IF;

    -- Cannot invite as owner
    IF p_role = 'owner' THEN
        RAISE EXCEPTION 'Cannot invite someone as owner';
    END IF;

    -- Verify inviter is library owner
    IF NOT EXISTS (
        SELECT 1 FROM library_members
        WHERE library_id = p_library_id
        AND user_id = p_invited_by
        AND role = 'owner'
    ) THEN
        RAISE EXCEPTION 'Only library owners can send invitations';
    END IF;

    -- Check if user already exists
    SELECT id INTO v_existing_user_id FROM users WHERE lower(email) = p_email;

    -- Check if user is already a member
    IF v_existing_user_id IS NOT NULL AND EXISTS (
        SELECT 1 FROM library_members
        WHERE library_id = p_library_id AND user_id = v_existing_user_id
    ) THEN
        RAISE EXCEPTION 'User is already a member of this library';
    END IF;

    -- Check for existing pending invitation
    IF EXISTS (
        SELECT 1 FROM library_invitations
        WHERE library_id = p_library_id
        AND lower(invited_email) = p_email
        AND status = 'pending'
        AND expires_at > NOW()
    ) THEN
        RAISE EXCEPTION 'A pending invitation already exists for this email';
    END IF;

    -- Expire any old pending invitations for this email/library combo
    UPDATE library_invitations
    SET status = 'expired'
    WHERE library_id = p_library_id
    AND lower(invited_email) = p_email
    AND status = 'pending';

    -- Create invitation
    INSERT INTO library_invitations (
        library_id,
        invited_email,
        invited_user_id,
        role,
        status,
        token,
        invited_by,
        expires_at
    )
    VALUES (
        p_library_id,
        p_email,
        v_existing_user_id,
        p_role,
        'pending',
        generate_invitation_token(),
        p_invited_by,
        NOW() + INTERVAL '7 days'
    )
    RETURNING * INTO v_invitation;

    RETURN v_invitation;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_invitation_token()
 RETURNS text
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN encode(gen_random_bytes(32), 'hex');
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_album_play_count(p_library_album_id uuid)
 RETURNS integer
 LANGUAGE plpgsql
 STABLE
AS $function$
DECLARE
    v_count INTEGER;
BEGIN
    SELECT COUNT(*)::INTEGER INTO v_count
    FROM listening_history
    WHERE library_album_id = p_library_album_id;

    RETURN v_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_device_status_summary()
 RETURNS TABLE(status text, count bigint)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    CASE
      WHEN d.last_seen_at > NOW() - INTERVAL '60 seconds' THEN 'online'
      WHEN d.last_seen_at IS NOT NULL THEN 'offline'
      ELSE 'never_connected'
    END as status,
    COUNT(*) as count
  FROM devices d
  GROUP BY 1
  ORDER BY 1;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_invitation_by_token(p_token text)
 RETURNS TABLE(invitation_id uuid, library_id uuid, library_name text, library_description text, invited_email text, role library_role, status invitation_status, inviter_name text, inviter_email text, expires_at timestamp with time zone, created_at timestamp with time zone, is_expired boolean)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        li.id AS invitation_id,
        li.library_id,
        l.name AS library_name,
        l.description AS library_description,
        li.invited_email,
        li.role,
        li.status,
        u.full_name AS inviter_name,
        u.email AS inviter_email,
        li.expires_at,
        li.created_at,
        (li.expires_at < NOW()) AS is_expired
    FROM library_invitations li
    JOIN libraries l ON l.id = li.library_id
    JOIN users u ON u.id = li.invited_by
    WHERE li.token = p_token;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_library_albums_with_details(p_library_id uuid, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0)
 RETURNS TABLE(library_album_id uuid, library_id uuid, album_id uuid, added_at timestamp with time zone, added_by uuid, notes text, is_favorite boolean, title text, artist text, year integer, genres text[], styles text[], label text, cover_image_url text, tracks jsonb, current_device_id uuid, current_device_name text)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        la.id AS library_album_id,
        la.library_id,
        la.album_id,
        la.added_at,
        la.added_by,
        la.notes,
        la.is_favorite,
        a.title,
        a.artist,
        a.year,
        a.genres,
        a.styles,
        a.label,
        a.cover_image_url,
        a.tracks,
        al.device_id AS current_device_id,
        d.name AS current_device_name
    FROM library_albums la
    JOIN albums a ON a.id = la.album_id
    LEFT JOIN LATERAL (
        SELECT alock.device_id
        FROM album_locations alock
        WHERE alock.library_album_id = la.id
        AND alock.removed_at IS NULL
        ORDER BY alock.detected_at DESC
        LIMIT 1
    ) al ON true
    LEFT JOIN consumer_devices d ON d.id = al.device_id
    WHERE la.library_id = p_library_id
    ORDER BY la.added_at DESC
    LIMIT p_limit
    OFFSET p_offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_online_device_count()
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN (
    SELECT COUNT(*)
    FROM devices
    WHERE last_seen_at > NOW() - INTERVAL '60 seconds'
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_or_create_consumer_user()
 RETURNS users
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_user users;
    v_auth_user_id UUID;
    v_email TEXT;
BEGIN
    v_auth_user_id := auth.uid();

    IF v_auth_user_id IS NULL THEN
        RAISE EXCEPTION 'Not authenticated';
    END IF;

    -- Try to find existing user by auth_user_id
    SELECT * INTO v_user
    FROM users
    WHERE auth_user_id = v_auth_user_id;

    IF v_user IS NOT NULL THEN
        RETURN v_user;
    END IF;

    -- Get email from auth.users
    SELECT email INTO v_email
    FROM auth.users
    WHERE id = v_auth_user_id;

    -- Try to find by email (existing admin user)
    SELECT * INTO v_user
    FROM users
    WHERE email = v_email;

    IF v_user IS NOT NULL THEN
        -- Link to auth_user_id
        UPDATE users
        SET auth_user_id = v_auth_user_id, last_login = NOW()
        WHERE id = v_user.id
        RETURNING * INTO v_user;
        RETURN v_user;
    END IF;

    -- Create new user
    INSERT INTO users (id, email, auth_user_id, created_at, last_login)
    VALUES (gen_random_uuid(), v_email, v_auth_user_id, NOW(), NOW())
    RETURNING * INTO v_user;

    RETURN v_user;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_popular_library_albums(p_library_id uuid, p_limit integer DEFAULT 5)
 RETURNS TABLE(id uuid, library_id uuid, album_id uuid, added_at timestamp with time zone, added_by uuid, notes text, is_favorite boolean, play_count bigint, title text, artist text, year integer, cover_image_url text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        la.id,
        la.library_id,
        la.album_id,
        la.added_at,
        la.added_by,
        la.notes,
        la.is_favorite,
        COALESCE(COUNT(lh.id), 0) AS play_count,
        a.title,
        a.artist,
        a.year,
        a.cover_image_url
    FROM library_albums la
    JOIN albums a ON a.id = la.album_id
    LEFT JOIN listening_history lh ON lh.library_album_id = la.id
    WHERE la.library_id = p_library_id
    GROUP BY la.id, la.library_id, la.album_id, la.added_at, la.added_by,
             la.notes, la.is_favorite, a.title, a.artist, a.year, a.cover_image_url
    ORDER BY play_count DESC, la.added_at DESC
    LIMIT p_limit;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_recently_played(p_user_id uuid, p_limit integer DEFAULT 10)
 RETURNS TABLE(library_album_id uuid, title text, artist text, cover_image_url text, last_played_at timestamp with time zone)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
    RETURN QUERY
    SELECT DISTINCT ON (la.id)
        la.id AS library_album_id,
        a.title,
        a.artist,
        a.cover_image_url,
        lh.played_at AS last_played_at
    FROM listening_history lh
    JOIN library_albums la ON la.id = lh.library_album_id
    JOIN albums a ON a.id = la.album_id
    WHERE lh.user_id = p_user_id
    ORDER BY la.id, lh.played_at DESC
    LIMIT p_limit;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_id_from_auth()
 RETURNS uuid
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
    v_user_id UUID;
BEGIN
    -- First try to find user by auth_user_id (consumer auth flow)
    SELECT id INTO v_user_id
    FROM users
    WHERE auth_user_id = auth.uid();

    -- If not found, try direct id match (for compatibility)
    IF v_user_id IS NULL THEN
        SELECT id INTO v_user_id
        FROM users
        WHERE id = auth.uid();
    END IF;

    RETURN v_user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_permissions(user_email text)
 RETURNS TABLE(permission_name text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT p.name
    FROM public.permissions p
    INNER JOIN public.user_permissions up ON p.id = up.permission_id
    INNER JOIN public.users u ON u.id = up.user_id
    WHERE u.email = user_email;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_consumer_auth_signup()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_existing_user_id UUID;
BEGIN
    -- Check if a user with this email already exists (e.g., admin user)
    SELECT id INTO v_existing_user_id
    FROM public.users
    WHERE email = NEW.email;

    IF v_existing_user_id IS NOT NULL THEN
        -- Link existing user to auth.users via auth_user_id
        UPDATE public.users
        SET
            auth_user_id = NEW.id,
            avatar_url = COALESCE(users.avatar_url, NEW.raw_user_meta_data->>'avatar_url'),
            full_name = COALESCE(users.full_name, NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'name'),
            last_login = NOW()
        WHERE id = v_existing_user_id;
    ELSE
        -- Create new user for consumer
        INSERT INTO public.users (
            id,
            email,
            full_name,
            avatar_url,
            auth_user_id,
            created_at,
            last_login
        )
        VALUES (
            gen_random_uuid(),
            NEW.email,
            COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'name'),
            NEW.raw_user_meta_data->>'avatar_url',
            NEW.id,
            NOW(),
            NOW()
        );
    END IF;

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_library()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    INSERT INTO library_members (library_id, user_id, role, joined_at)
    VALUES (NEW.id, NEW.created_by, 'owner', NOW())
    ON CONFLICT (library_id, user_id) DO NOTHING;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_library_member(lib_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM library_members
        WHERE library_id = lib_id
        AND user_id = get_user_id_from_auth()
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_library_owner(lib_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM library_members
        WHERE library_id = lib_id
        AND user_id = get_user_id_from_auth()
        AND role = 'owner'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.record_play(p_user_id uuid, p_library_album_id uuid, p_device_id uuid DEFAULT NULL::uuid)
 RETURNS listening_history
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_history listening_history;
BEGIN
    INSERT INTO listening_history (user_id, library_album_id, played_at, device_id)
    VALUES (p_user_id, p_library_album_id, NOW(), p_device_id)
    RETURNING * INTO v_history;

    RETURN v_history;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.reject_invitation_by_token(p_token text)
 RETURNS library_invitations
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_invitation library_invitations;
BEGIN
    UPDATE library_invitations
    SET status = 'rejected'
    WHERE token = p_token AND status = 'pending'
    RETURNING * INTO v_invitation;

    IF v_invitation IS NULL THEN
        RAISE EXCEPTION 'Invitation not found or not pending';
    END IF;

    RETURN v_invitation;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.resolve_tag_to_album(p_epc text)
 RETURNS TABLE(tag_id uuid, epc_identifier character varying, library_album_id uuid, album_id uuid, title text, artist text, cover_image_url text, library_id uuid, library_name text)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        t.id AS tag_id,
        t.epc_identifier,
        t.library_album_id,
        a.id AS album_id,
        a.title,
        a.artist,
        a.cover_image_url,
        l.id AS library_id,
        l.name AS library_name
    FROM rfid_tags t
    LEFT JOIN library_albums la ON la.id = t.library_album_id
    LEFT JOIN albums a ON a.id = la.album_id
    LEFT JOIN libraries l ON l.id = la.library_id
    WHERE t.epc_identifier = p_epc;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.revoke_invitation(p_invitation_id uuid, p_user_id uuid)
 RETURNS library_invitations
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_invitation library_invitations;
BEGIN
    -- Get invitation and verify ownership
    SELECT li.* INTO v_invitation
    FROM library_invitations li
    JOIN library_members lm ON lm.library_id = li.library_id
    WHERE li.id = p_invitation_id
    AND lm.user_id = p_user_id
    AND lm.role = 'owner'
    FOR UPDATE;

    IF v_invitation IS NULL THEN
        RAISE EXCEPTION 'Invitation not found or you do not have permission to revoke it';
    END IF;

    IF v_invitation.status != 'pending' THEN
        RAISE EXCEPTION 'Only pending invitations can be revoked';
    END IF;

    UPDATE library_invitations
    SET status = 'revoked'
    WHERE id = p_invitation_id
    RETURNING * INTO v_invitation;

    RETURN v_invitation;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.search_albums(p_query text, p_limit integer DEFAULT 20, p_offset integer DEFAULT 0)
 RETURNS SETOF albums
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
    RETURN QUERY
    SELECT *
    FROM albums
    WHERE to_tsvector('english', title || ' ' || artist || ' ' || COALESCE(label, ''))
          @@ plainto_tsquery('english', p_query)
    ORDER BY ts_rank(
        to_tsvector('english', title || ' ' || artist || ' ' || COALESCE(label, '')),
        plainto_tsquery('english', p_query)
    ) DESC
    LIMIT p_limit
    OFFSET p_offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_heartbeat_to_consumer_device()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
    UPDATE consumer_devices
    SET
        last_seen_at = NEW.device_timestamp,
        battery_level = COALESCE(NEW.battery_level, battery_level),
        firmware_version = COALESCE(NEW.firmware_version, firmware_version),
        -- If device was offline, mark it back online
        status = CASE
            WHEN status = 'offline' THEN 'online'
            ELSE status
        END
    WHERE serial_number = NEW.device_serial;

    -- Log if no matching device found (helpful for debugging)
    IF NOT FOUND THEN
        RAISE WARNING 'No consumer_device found for serial_number: %', NEW.device_serial;
    END IF;

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_heartbeat_to_device_and_unit()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_unit_id UUID;
  v_telemetry JSONB;
  v_battery_level INTEGER;
  v_is_charging BOOLEAN;
  v_wifi_rssi INTEGER;
  v_temperature_c NUMERIC;
  v_humidity_pct NUMERIC;
  v_firmware_version TEXT;
  v_heartbeat_ts TIMESTAMPTZ;
BEGIN
  v_heartbeat_ts := COALESCE(NEW.created_at, NOW());
  v_firmware_version := NEW.firmware_version;

  -- Build telemetry JSONB: prefer new telemetry column, fall back to individual columns
  IF NEW.telemetry IS NOT NULL THEN
    v_telemetry := NEW.telemetry;
  ELSE
    -- Build from individual columns (backward compatibility with current firmware)
    v_telemetry := jsonb_strip_nulls(jsonb_build_object(
      'unit_id', NEW.unit_id,
      'device_type', NEW.device_type,
      'uptime_sec', NEW.uptime_sec,
      'free_heap', NEW.free_heap,
      'min_free_heap', NEW.min_free_heap,
      'largest_free_block', NEW.largest_free_block,
      'wifi_rssi', NEW.wifi_rssi,
      'thread_rssi', NEW.thread_rssi,
      'battery_level', NEW.battery_level,
      'battery_charging', NEW.battery_charging
    ));
  END IF;

  -- Extract consumer-facing telemetry values
  -- COALESCE prefers telemetry JSONB, falls back to individual columns
  v_battery_level := COALESCE(
    (v_telemetry->>'battery_level')::INTEGER,
    NEW.battery_level
  );
  v_is_charging := COALESCE(
    (v_telemetry->>'battery_charging')::BOOLEAN,
    NEW.battery_charging
  );
  v_wifi_rssi := COALESCE(
    (v_telemetry->>'wifi_rssi')::INTEGER,
    NEW.wifi_rssi
  );
  v_temperature_c := (v_telemetry->>'temperature_c')::NUMERIC;
  v_humidity_pct := (v_telemetry->>'humidity_pct')::NUMERIC;

  -- Also extract firmware_version from telemetry if not set as column
  IF v_firmware_version IS NULL THEN
    v_firmware_version := v_telemetry->>'firmware_version';
  END IF;

  -- =========================================================================
  -- Update devices table (by mac_address)
  -- =========================================================================
  UPDATE devices
  SET
    last_seen_at = v_heartbeat_ts,
    firmware_version = COALESCE(v_firmware_version, firmware_version),
    latest_telemetry = v_telemetry,
    status = CASE WHEN status = 'offline' THEN 'online' ELSE status END
  WHERE mac_address = NEW.mac_address;

  -- =========================================================================
  -- Update units table (by serial number stored in heartbeats.unit_id)
  -- Only update fields that are present in this heartbeat's telemetry.
  -- This supports multi-device units where different devices report
  -- different capability data (e.g., main controller has wifi, RFID reader
  -- does not). COALESCE preserves existing values when this heartbeat
  -- doesn't include a particular field.
  -- =========================================================================
  IF NEW.unit_id IS NOT NULL THEN
    UPDATE units
    SET
      last_seen_at = GREATEST(last_seen_at, v_heartbeat_ts),
      is_online = true,
      firmware_version = COALESCE(v_firmware_version, firmware_version),
      battery_level = COALESCE(v_battery_level, battery_level),
      is_charging = COALESCE(v_is_charging, is_charging),
      wifi_rssi = COALESCE(v_wifi_rssi, wifi_rssi),
      temperature_c = COALESCE(v_temperature_c, temperature_c),
      humidity_pct = COALESCE(v_humidity_pct, humidity_pct)
    WHERE serial_number = NEW.unit_id
    RETURNING id INTO v_unit_id;

    IF v_unit_id IS NULL THEN
      RAISE LOG 'Heartbeat: no unit found for serial_number=%, mac=%',
        NEW.unit_id, NEW.mac_address;
    END IF;
  END IF;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_capabilities_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_command_on_ack()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_status TEXT;
  v_result JSONB;
  v_error_message TEXT;
BEGIN
  -- Handle command acknowledgement
  IF NEW.type = 'command_ack' AND NEW.command_id IS NOT NULL THEN
    UPDATE device_commands
    SET
      status = 'acknowledged',
      updated_at = NOW()
    WHERE id = NEW.command_id
      AND status IN ('pending', 'sent');

  -- Handle command result (completed or failed)
  ELSIF NEW.type = 'command_result' AND NEW.command_id IS NOT NULL THEN
    IF NEW.telemetry IS NOT NULL THEN
      v_status := COALESCE(NEW.telemetry->>'status', 'completed');
      v_result := NEW.telemetry->'result';
      v_error_message := NEW.telemetry->>'error_message';
    ELSE
      v_status := 'completed';
    END IF;

    UPDATE device_commands
    SET
      status = v_status,
      result = v_result,
      error_message = v_error_message,
      updated_at = NOW()
    WHERE id = NEW.command_id;
  END IF;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_device_commands_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_devices_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_machine_macros_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_notification_preferences_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_units_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.user_has_permission(user_email text, permission_name text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    user_is_admin BOOLEAN;
    has_perm BOOLEAN;
BEGIN
    -- Check if user is admin (admins have all permissions)
    SELECT is_admin INTO user_is_admin
    FROM public.users
    WHERE email = user_email;

    IF user_is_admin THEN
        RETURN TRUE;
    END IF;

    -- Check if user has the specific permission
    SELECT EXISTS (
        SELECT 1
        FROM public.user_permissions up
        INNER JOIN public.users u ON u.id = up.user_id
        INNER JOIN public.permissions p ON p.id = up.permission_id
        WHERE u.email = user_email
        AND p.name = permission_name
    ) INTO has_perm;

    RETURN has_perm;
END;
$function$
;

CREATE TRIGGER update_albums_updated_at BEFORE UPDATE ON albums FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER trigger_capabilities_updated_at BEFORE UPDATE ON capabilities FOR EACH ROW EXECUTE FUNCTION update_capabilities_updated_at();
CREATE TRIGGER update_customers_updated_at BEFORE UPDATE ON customers FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER on_device_command_created AFTER INSERT ON device_commands FOR EACH ROW WHEN (new.status = 'pending'::text) EXECUTE FUNCTION broadcast_device_command();
CREATE TRIGGER trigger_device_commands_updated_at BEFORE UPDATE ON device_commands FOR EACH ROW EXECUTE FUNCTION update_device_commands_updated_at();
CREATE TRIGGER device_heartbeat_sync_consumer_device AFTER INSERT ON device_heartbeats FOR EACH ROW EXECUTE FUNCTION sync_heartbeat_to_consumer_device();
CREATE TRIGGER on_command_ack_heartbeat AFTER INSERT ON device_heartbeats FOR EACH ROW WHEN (new.type = ANY (ARRAY['command_ack'::text, 'command_result'::text])) EXECUTE FUNCTION update_command_on_ack();
CREATE TRIGGER on_heartbeat_sync AFTER INSERT ON device_heartbeats FOR EACH ROW EXECUTE FUNCTION sync_heartbeat_to_device_and_unit();
CREATE TRIGGER update_device_types_updated_at BEFORE UPDATE ON device_types FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER trigger_devices_updated_at BEFORE UPDATE ON devices FOR EACH ROW EXECUTE FUNCTION update_devices_updated_at();
CREATE TRIGGER update_files_updated_at BEFORE UPDATE ON files FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_gcode_files_updated_at BEFORE UPDATE ON gcode_files FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER on_library_created AFTER INSERT ON libraries FOR EACH ROW EXECUTE FUNCTION handle_new_library();
CREATE TRIGGER update_libraries_updated_at BEFORE UPDATE ON libraries FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER machine_macros_updated_at_trigger BEFORE UPDATE ON machine_macros FOR EACH ROW EXECUTE FUNCTION update_machine_macros_updated_at();
CREATE TRIGGER notification_preferences_updated_at BEFORE UPDATE ON notification_preferences FOR EACH ROW EXECUTE FUNCTION update_notification_preferences_updated_at();
CREATE TRIGGER now_playing_events AFTER INSERT ON now_playing_events FOR EACH ROW EXECUTE FUNCTION supabase_functions.http_request('https://ddhcmhbwppiqrqmefynv.supabase.co/functions/v1/process-now-playing-event', 'POST', '{"Content-type":"application/json","Authorization":"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRkaGNtaGJ3cHBpcXJxbWVmeW52Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1OTk1MDA5MSwiZXhwIjoyMDc1NTI2MDkxfQ.KV7Ro37KMRr6D1zQEPd81hJMOTcLMO97oBbOVXnPPxc"}', '{}', '5000');
CREATE TRIGGER update_orders_updated_at BEFORE UPDATE ON orders FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_product_variants_updated_at BEFORE UPDATE ON product_variants FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_production_steps_updated_at BEFORE UPDATE ON production_steps FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_products_updated_at BEFORE UPDATE ON products FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_rfid_tag_rolls_updated_at BEFORE UPDATE ON rfid_tag_rolls FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_rfid_tags_updated_at BEFORE UPDATE ON rfid_tags FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_step_labels_updated_at BEFORE UPDATE ON step_labels FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_step_timers_updated_at BEFORE UPDATE ON step_timers FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_thread_credentials_updated_at BEFORE UPDATE ON thread_credentials FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_unit_timers_updated_at BEFORE UPDATE ON unit_timers FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER trigger_units_updated_at BEFORE UPDATE ON units FOR EACH ROW EXECUTE FUNCTION update_units_updated_at();
CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
